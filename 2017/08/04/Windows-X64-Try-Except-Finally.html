
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>  
  <meta charset="UTF-8">
  
    <title>Windows X64的Ring3层异常处理机制 | DbgTech</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Andy Guo">
    

    
    <meta name="description" content="前面自己总结了一下X86下的__try/__except/__finally等编译后的内容，以及异常分发到异常处理函数时的执行的过程。后面想看看X64上的内容，觉得X64的就不需要总结了，参考网上前行者的资料简单学习即可。当一点一点地看网上资料时，发现很多细节还是理解不透，无奈还是自己来总结一下。希望后来的朋友看到时不会有和我一样的感觉。后面会将参考到的资料列举一下，方便后来学习者参考，防止他们看">
<meta name="keywords" content="Windbg,Exception">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows X64的Ring3层异常处理机制">
<meta property="og:url" content="https://dbgtech.github.io/2017/08/04/Windows-X64-Try-Except-Finally.html">
<meta property="og:site_name" content="DbgTech">
<meta property="og:description" content="前面自己总结了一下X86下的__try/__except/__finally等编译后的内容，以及异常分发到异常处理函数时的执行的过程。后面想看看X64上的内容，觉得X64的就不需要总结了，参考网上前行者的资料简单学习即可。当一点一点地看网上资料时，发现很多细节还是理解不透，无奈还是自己来总结一下。希望后来的朋友看到时不会有和我一样的感觉。后面会将参考到的资料列举一下，方便后来学习者参考，防止他们看">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://dbgtech.github.io/img/2017-08-04-Windows-X64-Try-Except-Finally-PEExceptionDirectory.jpg">
<meta property="og:image" content="https://dbgtech.github.io/img/2017-08-04-Windows-X64-Try-Except-Finally-IDA-ExceptionInfoTable.jpg">
<meta property="og:updated_time" content="2018-05-19T07:03:13.413Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Windows X64的Ring3层异常处理机制">
<meta name="twitter:description" content="前面自己总结了一下X86下的__try/__except/__finally等编译后的内容，以及异常分发到异常处理函数时的执行的过程。后面想看看X64上的内容，觉得X64的就不需要总结了，参考网上前行者的资料简单学习即可。当一点一点地看网上资料时，发现很多细节还是理解不透，无奈还是自己来总结一下。希望后来的朋友看到时不会有和我一样的感觉。后面会将参考到的资料列举一下，方便后来学习者参考，防止他们看">
<meta name="twitter:image" content="https://dbgtech.github.io/img/2017-08-04-Windows-X64-Try-Except-Finally-PEExceptionDirectory.jpg">

    
    <link rel="alternative" href="/atom.xml" title="DbgTech" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="DbgTech" title="DbgTech"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="DbgTech">DbgTech</a></h1>
				<h2 class="blog-motto">—— 慢下来，享受思考的小确幸！</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/column">Column</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/04/Windows-X64-Try-Except-Finally.html" title="Windows X64的Ring3层异常处理机制" itemprop="url">Windows X64的Ring3层异常处理机制</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Andy Guo" target="_blank" itemprop="author">Andy Guo</a>
		
  <p class="article-time">
    <time datetime="2017-08-04T01:52:23.000Z" itemprop="datePublished"> 发表于 2017-08-04</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常信息注册"><span class="toc-number">1.</span> <span class="toc-text">异常信息注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常分发"><span class="toc-number">2.</span> <span class="toc-text">异常分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理和堆栈展开"><span class="toc-number">3.</span> <span class="toc-text">异常处理和堆栈展开</span></a></li></ol>
		
		</div>
		
		<p>前面自己总结了一下X86下的<code>__try/__except/__finally</code>等编译后的内容，以及异常分发到异常处理函数时的执行的过程。后面想看看X64上的内容，觉得X64的就不需要总结了，参考网上前行者的资料简单学习即可。当一点一点地看网上资料时，发现很多细节还是理解不透，无奈还是自己来总结一下。希望后来的朋友看到时不会有和我一样的感觉。后面会将参考到的资料列举一下，方便后来学习者参考，防止他们看这篇总结时也有我看他人学习笔记一样的感觉。</p>
<p>Visual C++支持三种异常，即C++异常处理，结构化异常处理，MFC异常。对于大多数C++程序，应该使用类型安全的C++异常处理，该处理可以确保在堆栈展开过程中调用对象析构函数；结构化异常处理为Windows提供供其自己的使用的，建议不要用于C++或MFC编程；MFC的异常不在讨论之列。其中标准C++异常处理是Visual C++上对Windows结构化异常进一步扩展，加入了展开中的对象析构等内容，所以这里也不会去总结标准C++的异常机制。</p>
<p>有前面的X86上的异常处理总结，这一篇总结起来就会相对简单一点。使用和上次相同的seh程序来解析（程序源码这里就不给出了）。与X86上类似的过程，在X64上也是一样，异常分发由RtlDispatchException函数负责，依次遍历“异常链表”，调用其过滤函数；如果过滤函数返回了<code>EXCEPTION_EXECUTE_HANDLER</code>则表示当前的异常处理函数负责处理该异常，然后进行全局展开、局部展开，最后调用异常处理函数，完成这一系列动作之后，程序恢复正常执行，执行<code>__try*</code>块（整个异常块）之后的代码；如果过滤函数返回继续执行即<code>EXCEPTION_CONTINUE_EXECUTION</code>，则返回异常出继续执行；如果返回<code>EXCEPTION_CONTINUE_SEARCH</code>，则继续遍历“异常链表”。当然没有处理异常最终会执行到线程起始处的异常处理函数，结果就是结束线程或进程。<br><a id="more"></a></p>
<h3 id="异常信息注册"><a href="#异常信息注册" class="headerlink" title="异常信息注册"></a>异常信息注册</h3><p>在X86上从异常处理块注册开始总结，那x64从哪里开始呢？其实也是要从类似的地方开始。X86上的异常处理块注册的方式是将异常信息放到栈上，而这种方式是可被缓存溢出攻击的，尽管Windows前前后后给出了很多缓解措施（SafeSEH等）。再一点，异常确实就是异常的，这就意味着异常并不是正常发生的情况；每一次调用使用了SEH的函数，这些构建异常链表的代码都要执行，这是非常不合理的设计。所以X64从设计之初就从异常信息块的注册上区别于x86的方式，对代码进行减肥。X64上，SEH变成了基于表的形式存在，也就是在代码编译时，这张表就被建立起来用来完整描述模块中的异常处理代码。表作为PE文件的一部分存在。当异常发生时，Windows解析这张表查找适当的异常处理函数。因为异常处理信息的查找线索放到了PE头中，这不会有缓存溢出攻击风险；其次，异常表是在编译过程中生成，不需要运行时额外指令（push/pop等指令）的执行消耗。X64这种基于表的异常处理也有缺点，首先它占用大量内存；其次虽然节省了正常代码执行过程中构建异常帧，但是它的异常处理的代价要比X86基于帧的异常处理高很多。</p>
<p>前面说过，X64模块上的异常处理信息是被保存到PE文件中，这里给出seh.exe的PE信息。从下面图1中可以看到，异常表保存的地方是PE文件中Exception目录中，它在seh.exe中的RVA为0x11000，大小为0x774字节。为了进一步验证，将seh.exe用IDA反汇编，查找偏移为0x11000位置内容，如图2所示。从图中可以看到，在0x140011000处为ExceptionDir表，每一项都是<code>RUNTIME_FUNCTION</code>类型的元素。</p>
<div align="center"><br><img src="/img/2017-08-04-Windows-X64-Try-Except-Finally-PEExceptionDirectory.jpg" alt="图1 PE文件中的异常信息表"><br></div>

<div align="center"><br><img src="/img/2017-08-04-Windows-X64-Try-Except-Finally-IDA-ExceptionInfoTable.jpg" alt="图2 IDA中Exception Directory"><br></div>

<p>保存在上述这个列表中的函数都是非叶函数，这些函数有什么特点呢？这些函数或者有分配栈空间，或者调用了其他的函数，或者有异常处理。在下面引用了一段MSDN对X64上关于函数类型的论述，可以体会一下官方解释。</p>
<blockquote>
<p>There are basically two types of functions. A function that requires a stack frame is called a frame function. A function that does not require a stack frame is called a leaf function.</p>
</blockquote>
<blockquote>
<p>A frame function is a function that allocates stack space, calls other functions, saves nonvolatile registers, or uses exception handling. It also requires a function table entry. A frame function requires a prolog and an epilog. A frame function can dynamically allocate stack space and can employ a frame pointer. A frame function has the full capabilities of this calling standard at its disposal.</p>
</blockquote>
<blockquote>
<p>If a frame function does not call another function then it is not required to align the stack (referenced in Section Stack Allocation).</p>
</blockquote>
<blockquote>
<p>A leaf function is one that does not require a function table entry. It can’t make changes to any nonvolatile registers, including RSP, which means that it can’t call any functions or allocate stack space. It is allowed to leave the stack unaligned while it executes.</p>
</blockquote>
<blockquote>
<p>注：这块有个疑问，“如果帧函数不调用其他的函数，那么就不要求它对齐栈”，不太明白这句要表达什么意思。有知道的朋友欢迎留言给我，让我也长点知识^_^。</p>
</blockquote>
<p>那么就是说一个<code>RUNTIME_FUNCTION</code>结构体代表了一个非页函数。从下述的代码块中可以看到该结构体的定义，定义比较简单，BeginAddress，EndAddress两个成员分别为函数开始和结束的RVA（这个如果不好理解，在后面看到异常分发代码时就理解了），UnWindData则是和这个函数相关的异常处理信息。从三个元素的数据类型ULONG类型可知它是无法表示X64模块中的指针的，即此处是一个相对于ImageBase的偏移值（即RVA），并不是指针或地址值。</p>
<blockquote>
<p>从前面可知，异常函数表是编译器编译中形成。对于JIT编译器动态生成的函数可以使用RtlInstallFunctionTableCallback或RtlAddFunctionTable构建这么一个函数表，否则函数调用过程中会出现不可靠异常处理。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _RUNTIME_FUNCTION &#123;</span><br><span class="line">    ULONG BeginAddress;</span><br><span class="line">    ULONG EndAddress;</span><br><span class="line">    ULONG UnwindData;</span><br><span class="line">&#125; RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;</span><br></pre></td></tr></table></figure>
<p>UnWindData成员的值其实是一个UNWIND_INFO结构体的RVA，UNWIND_INFO结构体保存了异常处理的信息，其定义如下代码块所示。其中各个成员的函数都做了注释，不再一一解释。结构体<code>UNWIND_CODE</code>描述了非叶函数执行时如何建立起栈空间。为了完美地展开栈帧，异常分发器需要了解栈帧中栈空间分配数量，非易失寄存器保存位置，以及其他操作栈的行为。为了恢复调用者的栈帧，这些信息是必须的。除了保存栈帧建立信息，<code>UNWIND_INFO</code>结构体也会描述异常处理信息，例如异常处理函数。只有在Flags域包含了<code>ENW FLAG EHANDLER</code>时，ExceptionHandler和ExceptionData成员才会存在，并且保存了异常处理函数及异常数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#define UNW_FLAG_NHANDLER 0x0		// 表示既没有 EXCEPT_FILTER 也没有 EXCEPT_HANDLER。</span><br><span class="line">#define UNW_FLAG_EHANDLER 0x1		// 表示该函数有 EXCEPT_FILTER &amp; EXCEPT_HANDLER。</span><br><span class="line">#define UNW_FLAG_UHANDLER 0x2		// 表示该函数有 FINALLY_HANDLER。</span><br><span class="line">#define UNW_FLAG_CHAININFO 0x4		// 表示该函数有多个 UNWIND_INFO，它们串接在一起（所谓的 chain）。</span><br><span class="line"></span><br><span class="line">typedef struct _UNWIND_INFO &#123;</span><br><span class="line">    UBYTE Version         : 3;		// 版本号，目前为1</span><br><span class="line">    UBYTE Flags           : 5;		// Flags，值为上述define定义的值</span><br><span class="line">    UBYTE SizeOfProlog;				// Prolog 的大小（字节单位）</span><br><span class="line">    UBYTE CountOfCodes;				// 展开代码的计数(表示当前UNWIND_INFO包含多少个UNWIND_CODE结构)</span><br><span class="line">    UBYTE FrameRegister  : 4;		// 如果函数建立了栈帧，它表示栈帧的索引（相对于 CONTEXT::RAX 的偏移）。否则该成员的值为0。</span><br><span class="line">    UBYTE FrameOffset    : 4;		// 表示FrameRegister距离函数最初栈顶（完成prolog，没有执行其他指令时的栈顶）偏移</span><br><span class="line">    UNWIND_CODE UnwindCode[1];		// 展开代码数组 USHORT * n</span><br><span class="line">									// UnwindCode 数组详细记录了函数修改栈、保存非易失性寄存器的指令</span><br><span class="line">    //</span><br><span class="line">    // The unwind codes are followed by an optional DWORD aligned field that</span><br><span class="line">    // contains the exception handler address or a function table entry if</span><br><span class="line">    // chained unwind information is specified. If an exception handler address</span><br><span class="line">    // is specified, then it is followed by the language specified exception</span><br><span class="line">    // handler data.</span><br><span class="line">    //</span><br><span class="line">	union &#123;</span><br><span class="line">        //</span><br><span class="line">        // If (Flags &amp; UNW_FLAG_EHANDLER)</span><br><span class="line">        //</span><br><span class="line">    	OPTIONAL ULONG ExceptionHandler;</span><br><span class="line">        //</span><br><span class="line">        // Else if (Flags &amp; UNW_FLAG_CHAININFO)</span><br><span class="line">        //</span><br><span class="line">        OPTIONAL ULONG FunctionEntry;</span><br><span class="line">	&#125;;</span><br><span class="line">    //</span><br><span class="line">    // If (Flags &amp; UNW_FLAG_EHANDLER)</span><br><span class="line">    //</span><br><span class="line">    OPTIONAL ULONG ExceptionData[];</span><br><span class="line">&#125; UNWIND_INFO, *PUNWIND_INFO;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 展开操作码</span><br><span class="line">typedef enum _UNWIND_OP_CODES &#123;</span><br><span class="line">    UWOP_PUSH_NONVOL = 0, /* info == register number */</span><br><span class="line">    UWOP_ALLOC_LARGE,     /* no info, alloc size in next 2 slots */</span><br><span class="line">    UWOP_ALLOC_SMALL,     /* info == size of allocation / 8 - 1 */</span><br><span class="line">    UWOP_SET_FPREG,       /* no info, FP = RSP + UNWIND_INFO.FPRegOffset*16 */</span><br><span class="line">    UWOP_SAVE_NONVOL,     /* info == register number, offset in next slot */</span><br><span class="line">    UWOP_SAVE_NONVOL_FAR, /* info == register number, offset in next 2 slots */</span><br><span class="line">    UWOP_SAVE_XMM128,     /* info == XMM reg number, offset in next slot */</span><br><span class="line">    UWOP_SAVE_XMM128_FAR, /* info == XMM reg number, offset in next 2 slots */</span><br><span class="line">    UWOP_PUSH_MACHFRAME   /* info == 0: no error-code, 1: error-code */</span><br><span class="line">&#125; UNWIND_CODE_OPS;</span><br><span class="line"></span><br><span class="line">typedef union _UNWIND_CODE &#123;</span><br><span class="line">	struct &#123;</span><br><span class="line">		UBYTE CodeOffset;		// Prolog 中的偏移量</span><br><span class="line">		UBYTE UnwindOp : 4;		// 展开操作码</span><br><span class="line">		UBYTE OpInfo : 4;		// 操作信息</span><br><span class="line">	&#125;;</span><br><span class="line">	USHORT FrameOffset;</span><br><span class="line">&#125; UNWIND_CODE, *PUNWIND_CODE;</span><br></pre></td></tr></table></figure>
<p>ExceptionData其实是一个指向<code>SCOPE_TABLE</code>结构体的偏移，这个结构体是一个变长的结构体。ScopeTable用于表述每一个<code>__try/__except</code>或<code>__try/__finally</code>，每一个表项对应一个<code>__try</code>语句。与X86的ScopeTable相对比，这块就相对比较容易理解了。但是与X86不同的是X64上并没有记录try层级的tryLevel成员存在。x64上则是通过表项的先后来对应于try的先后与内外层。对于并列的多个try，先出现的try语句对应于ScopeTable中index较小的项；对于嵌套的try，最内层的try在ScopeTable中index越小，即遍历时要先遍历最内层try，再遍历外层try语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _SCOPE_TABLE &#123;</span><br><span class="line">    ULONG Count;</span><br><span class="line">    struct</span><br><span class="line">    &#123;</span><br><span class="line">        ULONG BeginAddress;</span><br><span class="line">        ULONG EndAddress;</span><br><span class="line">        ULONG HandlerAddress;	// __except后()中代码（函数或代码块） 异常过滤器或异常处理器</span><br><span class="line">        ULONG JumpTarget;		// __except后面&#123;&#125;代码块第一条指令的地址</span><br><span class="line">    &#125; ScopeRecord[1];</span><br><span class="line">&#125; SCOPE_TABLE, *PSCOPE_TABLE;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：Windows X64的函数中没有压栈出栈操作，所有涉及栈操作的全都在调用者函数中或函数的prolog中完成，这样有利于遇到异常时进行展开。再者，x64的函数调用方式中，RCX/RDX/R8/R9等四个寄存器用于传递前四个参数（整数或指针），但是函数调用者依然要在栈上为这四个参数分配空间，即0x20 bytes的未初始化内存。即紧邻返回地址的是0x20 Bytes未初始化内存空间（register parameter area），接下来才是第五个参数（stack parameter area）。寄存器参数区总是要分配的，即使被调用的函数的参数少于四个；同时这个寄存器参数区是属于被调用函数的，它本来的用途是保存寄存器参数，以使得这些寄存器参数持久化，但是在有些情况下可以看到被调用函数中会拿着四个参数空间来保存非易失寄存器（如RBP，RBX，RDI，RSI，R12～R15等）。这么安排调用方式，一个不好的地方是函数调用中要最少消耗0x20的栈空间。</p>
</blockquote>
<p>上面说了那么多，下面用Windbg解析一下Seh.exe的SehTest函数，如下代码块所示调试结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; lm m seh			// 查一下seh 的基地址</span><br><span class="line">Browse full module list</span><br><span class="line">start             end                 module name</span><br><span class="line">00000001`3f1d0000 00000001`3f1e4000   seh        (private pdb symbols)  D:\DebugWorks\Exception-Dispatch\X64-Exception\seh\x64\Release\seh.pdb</span><br><span class="line"></span><br><span class="line">0:000&gt; dt 001`3f1e1000 _RUNTIME_FUNCTION		// 根据前面PE文件解析看的结果知道异常列表位于0x11000偏移处</span><br><span class="line">seh!_RUNTIME_FUNCTION</span><br><span class="line">   +0x000 BeginAddress     : 0x1000				// SehTest起始地址的RVA值</span><br><span class="line">   +0x004 EndAddress       : 0x1038				// SehTest结束地址的RVA值，从反汇编可知0x38是函数“开区间”，并不包含该值汇编</span><br><span class="line">   +0x008 UnwindData       : 0xbd04				// 异常信息数据保存RVA</span><br><span class="line"></span><br><span class="line">0:000&gt; uf seh!SehTest</span><br><span class="line">seh!SehTest [c:\users\administrator\desktop\x64-exception\seh\seh\seh.cpp @ 31]:</span><br><span class="line">   31 00000001`3f1d1000 4883ec58        sub     rsp,58h</span><br><span class="line">   32 00000001`3f1d1004 c744246000000000 mov     dword ptr [rsp+60h],0</span><br><span class="line">   36 00000001`3f1d100c c744246011111111 mov     dword ptr [rsp+60h],11111111h</span><br><span class="line">   37 00000001`3f1d1014 eb08            jmp     seh!SehTest+0x1e (00000001`3f1d101e)  Branch</span><br><span class="line"></span><br><span class="line">seh!SehTest+0x1e [c:\users\administrator\desktop\x64-exception\seh\seh\seh.cpp @ 51]:</span><br><span class="line">   51 00000001`3f1d101e c704250000000033333333 mov dword ptr [0],33333333h</span><br><span class="line">   55 00000001`3f1d1029 c744246030333333 mov     dword ptr [rsp+60h],33333330h</span><br><span class="line">   57 00000001`3f1d1031 eb00            jmp     seh!SehTest+0x33 (00000001`3f1d1033)  Branch</span><br><span class="line"></span><br><span class="line">seh!SehTest+0x33 [c:\users\administrator\desktop\x64-exception\seh\seh\seh.cpp @ 64]:</span><br><span class="line">   64 00000001`3f1d1033 4883c458        add     rsp,58h</span><br><span class="line">   64 00000001`3f1d1037 c3              ret</span><br><span class="line">	  00000001`3f1d1038 cc              int     3</span><br><span class="line"></span><br><span class="line">0:000&gt; dt 001`3f1d0000 + 0xbd04 _UNWIND_INFO		// 异常信息</span><br><span class="line">seh!_UNWIND_INFO</span><br><span class="line">   +0x000 Version          : 0y001</span><br><span class="line">   +0x000 Flags            : 0y00011 (0x3)			// UNW_FLAG_EHANDLER | UNW_FLAG_UHANDLER</span><br><span class="line">   +0x001 SizeOfProlog     : 0x4 &apos;&apos;					// 处理栈的汇编代码所占字节数</span><br><span class="line">   +0x002 CountOfCodes     : 0x1 &apos;&apos;					// UnwindCode数组元素个数</span><br><span class="line">   +0x003 FrameRegister    : 0y0000</span><br><span class="line">   +0x003 FrameOffset      : 0y0000</span><br><span class="line">   +0x004 UnwindCode       : [1] _UNWIND_CODE</span><br><span class="line">0:000&gt; dt 001`3f1d0000 + 0xbd04 + 4 _UNWIND_CODE	//</span><br><span class="line">seh!_UNWIND_CODE</span><br><span class="line">   +0x000 CodeOffset       : 0x4 &apos;&apos;			// prolog 后的第一个指令偏移</span><br><span class="line">   +0x001 UnwindOp         : 0y0010			// UWOP_ALLOC_SMALL</span><br><span class="line">   +0x001 OpInfo           : 0y1010			// 10</span><br><span class="line">   +0x000 FrameOffset      : 0xa204</span><br><span class="line">0:000&gt; dd 001`3f1d0000 + 0xbd04</span><br><span class="line">00000001`3f1dbd04  00010419 0000a204 0000144c 00000003</span><br><span class="line">00000001`3f1dbd14  0000100c 00001016 00009370 00001016</span><br><span class="line">00000001`3f1dbd24  0000101e 00001029 000093c0 00000000</span><br><span class="line">00000001`3f1dbd34  0000101e 00001033 000093d0 00001033</span><br><span class="line">00000001`3f1dbd44  00010401 00004204 0000bd78 00000000</span><br><span class="line">00000001`3f1dbd54  00000000 0000c47a 0000a000 00000000</span><br><span class="line">00000001`3f1dbd64  00000000 00000000 00000000 00000000</span><br><span class="line">00000001`3f1dbd74  00000000 0000bfa0 00000000 0000bfb4</span><br><span class="line">0:000&gt; u 001`3f1d0000 + 0000144c 					// UNWIND_INFO后有一个异常处理函数</span><br><span class="line">seh!__C_specific_handler:</span><br><span class="line">00000001`3f1d144c 488bc4          mov     rax,rsp</span><br><span class="line">00000001`3f1d144f 48895808        mov     qword ptr [rax+8],rbx</span><br><span class="line">00000001`3f1d1453 48896818        mov     qword ptr [rax+18h],rbp</span><br><span class="line">00000001`3f1d1457 48897020        mov     qword ptr [rax+20h],rsi</span><br><span class="line">00000001`3f1d145b 48895010        mov     qword ptr [rax+10h],rdx</span><br><span class="line">00000001`3f1d145f 57              push    rdi</span><br><span class="line">00000001`3f1d1460 4154            push    r12</span><br><span class="line">00000001`3f1d1462 4155            push    r13</span><br><span class="line">0:000&gt; dt 0000001`3f1dbd04 + 0c _SCOPE_TABLE		// 异常处理函数RVA 后面就是ScopeTable了，本例中有三个try，表大小为3</span><br><span class="line">seh!_SCOPE_TABLE</span><br><span class="line">   +0x000 Count            : 3</span><br><span class="line">   +0x004 ScopeRecord      : [1] &lt;unnamed-tag&gt;</span><br></pre></td></tr></table></figure>
<p>前面仅仅对<code>_UNWIND_CODE</code>结构体内容作了注释，并没有解释它的含义。这里以调试中出现的这个<code>_UNWIND_CODE</code>中的内容为例，解释一下。根据前面的叙述，<code>_UNWIND_CODE</code>是用作描述当前函数的栈操作，非易失寄存器存储等使用。CodeOffset意思是从prolog开始到结束prolog操作最后一个指令的下一条指令的偏移，即<code>sub rsp,58h</code>指令后面一条指令的偏移（相对于prolog起始地址）；UnwindOp为展开造作吗，0y10即2，对应于<code>UWOP_ALLOC_SMALL</code>，它的含义是在栈上分配一个小尺寸的空间，大小为OpInfo成员乘以8再加上8，本例中即为88字节，而函数prolog的<code>sub rsp,58h</code>指令保留的空间及88字节。跟多相关的内容可以参考MSDN的官方解释：<a href="https://msdn.microsoft.com/en-us/library/ck9asaa9.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/ck9asaa9.aspx</a></p>
<h3 id="异常分发"><a href="#异常分发" class="headerlink" title="异常分发"></a>异常分发</h3><p>上一节总结了一下X64上异常表的“注册”，以及异常表的内容。这块覆盖一些之前总结过的异常分发的内容，总结一下X64中如何用基于异常表的新形式分发异常。这里直接将WRK中的X64的RtlDispatchException函数借用过来用作说明，具体内容见注释。源代码路径为<code>*\WRK-v1.2\WRK-v1.2\base\ntos\rtl\amd64\exdsptch.c</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line">// 异常分发中用的几个返回值</span><br><span class="line">#define EXCEPTION_NONCONTINUABLE   0x0001</span><br><span class="line">#define EXCEPTION_UNWINDING        0x0002</span><br><span class="line">#define EXCEPTION_EXIT_UNWIND      0x0004</span><br><span class="line">#define EXCEPTION_STACK_INVALID    0x0008</span><br><span class="line">#define EXCEPTION_NESTED_CALL      0x0010</span><br><span class="line">#define EXCEPTION_TARGET_UNWIND    0x0020</span><br><span class="line">#define EXCEPTION_COLLIDED_UNWIND  0x0040</span><br><span class="line">#define EXCEPTION_UNWIND           0x0066</span><br><span class="line"></span><br><span class="line">/*++</span><br><span class="line">Routine Description:</span><br><span class="line">    This function attempts to dispatch an exception to a frame based</span><br><span class="line">    handler by searching backwards through the stack based call frames.</span><br><span class="line">    The search begins with the frame specified in the context record and</span><br><span class="line">    continues backward until either a handler is found that handles the</span><br><span class="line">    exception, the stack is found to be invalid (i.e., out of limits or</span><br><span class="line">    unaligned), or the end of the call hierarchy is reached.</span><br><span class="line"></span><br><span class="line">    As each frame is encounter, the PC where control left the corresponding</span><br><span class="line">    function is determined and used to lookup exception handler information</span><br><span class="line">    in the runtime function table built by the linker. If the respective</span><br><span class="line">    routine has an exception handler, then the handler is called. If the</span><br><span class="line">    handler does not handle the exception, then the prologue of the routine</span><br><span class="line">    is executed backwards to &quot;unwind&quot; the effect of the prologue and then</span><br><span class="line">    the next frame is examined.</span><br><span class="line">	函数向后回溯基于栈的调用帧，尝试将异常分发给基于帧的处理器。搜索开始于Context记录中指定的帧，</span><br><span class="line">    直到找到处理该异常的处理器，或者栈帧变成无效，再或者到了调用层次的末尾。</span><br><span class="line"></span><br><span class="line">    每次遇到一个栈帧，控制离开对应函数的PC值确定了，并且用于在链接器构建的运行时函数表中寻找异常处理器信息。</span><br><span class="line">    如果每一个函数都有一个异常处理器，就会调用异常处理器。如果异常处理器不处理该异常，然后函数的prologue就</span><br><span class="line">    会被逆向执行以“展开”prologue对栈的影响，然后再检查下一个栈帧。</span><br><span class="line">Arguments:</span><br><span class="line">    ExceptionRecord - Supplies a pointer to an exception record. 异常记录的指针</span><br><span class="line">    ContextRecord - Supplies a pointer to a context record.	异常环境记录的指针</span><br><span class="line"></span><br><span class="line">Return Value:</span><br><span class="line">    If the exception is handled by one of the frame based handlers, then</span><br><span class="line">    a value of TRUE is returned. Otherwise a value of FALSE is returned.</span><br><span class="line">	如果异常被处理，返回TRUE，否则返回FALSE</span><br><span class="line">--*/</span><br><span class="line"></span><br><span class="line">BOOLEAN RtlDispatchException ( IN PEXCEPTION_RECORD ExceptionRecord, IN PCONTEXT ContextRecord )</span><br><span class="line">&#123;</span><br><span class="line">    BOOLEAN Completion = FALSE;</span><br><span class="line">    CONTEXT ContextRecord1;</span><br><span class="line">    ULONG64 ControlPc;</span><br><span class="line">    DISPATCHER_CONTEXT DispatcherContext;</span><br><span class="line">    EXCEPTION_DISPOSITION Disposition;</span><br><span class="line">    ULONG64 EstablisherFrame;</span><br><span class="line">    ULONG ExceptionFlags;</span><br><span class="line">    PEXCEPTION_ROUTINE ExceptionRoutine;</span><br><span class="line">    PRUNTIME_FUNCTION FunctionEntry;</span><br><span class="line">    PVOID HandlerData;</span><br><span class="line">    ULONG64 HighLimit;</span><br><span class="line">    PUNWIND_HISTORY_TABLE HistoryTable;</span><br><span class="line">    ULONG64 ImageBase;</span><br><span class="line">    ULONG Index;</span><br><span class="line">    ULONG64 LowLimit;</span><br><span class="line">    ULONG64 NestedFrame;</span><br><span class="line">    BOOLEAN Repeat;</span><br><span class="line">    ULONG ScopeIndex;</span><br><span class="line">    UNWIND_HISTORY_TABLE UnwindTable;</span><br><span class="line"></span><br><span class="line">	// 调用注册的向量化异常处理器</span><br><span class="line">	if ( (unsigned __int8)RtlpCallVectoredHandlers(ExceptionRecord, ContextRecord, 0i64) )</span><br><span class="line">	&#123;</span><br><span class="line">		Completion = 1;</span><br><span class="line">		return Completion;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Get current stack limits, copy the context record, get the initial</span><br><span class="line">    // PC value, capture the exception flags, and set the nested exception</span><br><span class="line">    // frame pointer.</span><br><span class="line">    //</span><br><span class="line"></span><br><span class="line">    RtlpGetStackLimits(&amp;LowLimit, &amp;HighLimit);	// 获取栈帧界限，防止遍历中超出栈帧界限</span><br><span class="line">    RtlpCopyContext(&amp;ContextRecord1, ContextRecord);	// 拷贝异常环境记录</span><br><span class="line">    ControlPc = (ULONG64)ExceptionRecord-&gt;ExceptionAddress;	// 发生异常时的执行代码的地址（RIP）</span><br><span class="line">    ExceptionFlags = ExceptionRecord-&gt;ExceptionFlags &amp; EXCEPTION_NONCONTINUABLE;</span><br><span class="line">    NestedFrame = 0;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Initialize the unwind history table.	初始化展开历史表，用于二次调用时加速</span><br><span class="line">    //</span><br><span class="line"></span><br><span class="line">    HistoryTable = &amp;UnwindTable;</span><br><span class="line">    HistoryTable-&gt;Count = 0;</span><br><span class="line">    HistoryTable-&gt;Search = UNWIND_HISTORY_TABLE_NONE;</span><br><span class="line">    HistoryTable-&gt;LowAddress = - 1;</span><br><span class="line">    HistoryTable-&gt;HighAddress = 0;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Start with the frame specified by the context record and search</span><br><span class="line">    // backwards through the call frame hierarchy attempting to find an</span><br><span class="line">    // exception handler that will handle the exception.</span><br><span class="line">    // 搜索开始于Context找那个指定的栈帧，向后搜索调用栈帧层次尝试找到可以处理该异常的异常处理函数。</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        //</span><br><span class="line">        // Lookup the function table entry using the point at which control</span><br><span class="line">        // left the procedure. 控制离开异常函数时的代码执行指针值 查找函数表（即发生异常时的RIP）</span><br><span class="line">        //</span><br><span class="line"></span><br><span class="line">		// 这个函数代码不再列出，函数作用就是搜索给出ControlPC所在RUNTIME_FUNCTION表项。</span><br><span class="line">        // 如果HistoryTable有值，且指定搜索方式，则从历史表中搜索，否则从映像的异常函数表中搜索（二分法）</span><br><span class="line">        FunctionEntry = RtlLookupFunctionEntry(ControlPc, &amp;ImageBase, HistoryTable);</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        // If there is a function table entry for the routine, then virtually</span><br><span class="line">        // unwind to the caller of the current routine to obtain the virtual</span><br><span class="line">        // frame pointer of the establisher and check if there is an exception</span><br><span class="line">        // handler for the frame.</span><br><span class="line">        // 如果在函数表中有一个发生异常函数对应的表项，然后虚拟展开当前函数到调用者中</span><br><span class="line">        // 获取调用者的虚拟帧指针，确定该函数帧是否有异常处理器</span><br><span class="line"></span><br><span class="line">        if (FunctionEntry != NULL) &#123; 	// X64中比较关键的一个函数，后面分析</span><br><span class="line">            ExceptionRoutine = RtlVirtualUnwind(UNW_FLAG_EHANDLER,</span><br><span class="line">                                                ImageBase,</span><br><span class="line">                                                ControlPc,</span><br><span class="line">                                                FunctionEntry,</span><br><span class="line">                                                &amp;ContextRecord1,</span><br><span class="line">                                                &amp;HandlerData,</span><br><span class="line">                                                &amp;EstablisherFrame,</span><br><span class="line">                                                NULL);</span><br><span class="line"></span><br><span class="line">            //</span><br><span class="line">            // If the establisher frame pointer is not within the specified</span><br><span class="line">            // stack limits or the established frame pointer is unaligned,</span><br><span class="line">            // then set the stack invalid flag in the exception record and</span><br><span class="line">            // return exception not handled. Otherwise, check if the current</span><br><span class="line">            // routine has an exception handler.</span><br><span class="line">            // 栈帧建立者的栈帧不再特定栈界限或建立起来的栈帧指针没有对其，设置栈帧无效，返回异常未处理。</span><br><span class="line"></span><br><span class="line">            if (RtlpIsFrameInBounds(&amp;LowLimit, EstablisherFrame, &amp;HighLimit) == FALSE) &#123;</span><br><span class="line">                ExceptionFlags |= EXCEPTION_STACK_INVALID;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            &#125; else if (ExceptionRoutine != NULL) &#123;</span><br><span class="line"></span><br><span class="line">                //</span><br><span class="line">                // The frame has an exception handler.</span><br><span class="line">                //</span><br><span class="line">                // A linkage routine written in assembler is used to actually</span><br><span class="line">                // call the actual exception handler. This is required by the</span><br><span class="line">                // exception handler that is associated with the linkage</span><br><span class="line">                // routine so it can have access to two sets of dispatcher</span><br><span class="line">                // context when it is called.</span><br><span class="line">                //</span><br><span class="line">                // Call the language specific handler.</span><br><span class="line">                // 如果栈帧有异常处理器。调用语言指定异常处理器</span><br><span class="line"></span><br><span class="line">                ScopeIndex = 0;</span><br><span class="line">                do &#123;</span><br><span class="line"></span><br><span class="line">                    //</span><br><span class="line">                    // Log the exception if exception logging is enabled.</span><br><span class="line">                    // 记录异常发生日志</span><br><span class="line">                    ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;</span><br><span class="line">                    if ((NtGlobalFlag &amp; FLG_ENABLE_EXCEPTION_LOGGING) != 0) &#123;</span><br><span class="line">                        Index = RtlpLogExceptionHandler(ExceptionRecord,</span><br><span class="line">                                                        &amp;ContextRecord1,</span><br><span class="line">                                                        ControlPc,</span><br><span class="line">                                                        FunctionEntry,</span><br><span class="line">                                                        sizeof(RUNTIME_FUNCTION));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //</span><br><span class="line">                    // Clear repeat, set the dispatcher context, and call the</span><br><span class="line">                    // exception handler.</span><br><span class="line">                    // 设置分发器环境，调用异常处理器</span><br><span class="line">                    Repeat = FALSE;</span><br><span class="line">                    DispatcherContext.ControlPc = ControlPc;</span><br><span class="line">                    DispatcherContext.ImageBase = ImageBase;</span><br><span class="line">                    DispatcherContext.FunctionEntry = FunctionEntry;</span><br><span class="line">                    DispatcherContext.EstablisherFrame = EstablisherFrame;</span><br><span class="line">                    DispatcherContext.ContextRecord = &amp;ContextRecord1;</span><br><span class="line">                    DispatcherContext.LanguageHandler = ExceptionRoutine;</span><br><span class="line">                    DispatcherContext.HandlerData = HandlerData;</span><br><span class="line">                    DispatcherContext.HistoryTable = HistoryTable;</span><br><span class="line">                    DispatcherContext.ScopeIndex = ScopeIndex;</span><br><span class="line">                    // 借用链接器的函数，调用真正的异常处理器函数（X64上就是 __C_specific_handler）</span><br><span class="line">                    Disposition = RtlpExecuteHandlerForException(ExceptionRecord,</span><br><span class="line">                    											 EstablisherFrame,</span><br><span class="line">                                                                 ContextRecord,</span><br><span class="line">                                                                 &amp;DispatcherContext);</span><br><span class="line"></span><br><span class="line">                    if ((NtGlobalFlag &amp; FLG_ENABLE_EXCEPTION_LOGGING) != 0) &#123;</span><br><span class="line">                        RtlpLogLastExceptionDisposition(Index, Disposition);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //</span><br><span class="line">                    // Propagate noncontinuable exception flag.</span><br><span class="line">                    //</span><br><span class="line">                    ExceptionFlags |=</span><br><span class="line">                        (ExceptionRecord-&gt;ExceptionFlags &amp; EXCEPTION_NONCONTINUABLE);</span><br><span class="line"></span><br><span class="line">                    //</span><br><span class="line">                    // If the current scan is within a nested context and the</span><br><span class="line">                    // frame just examined is the end of the nested region,</span><br><span class="line">                    // then clear the nested context frame and the nested</span><br><span class="line">                    // exception flag in the exception flags.</span><br><span class="line">                    // 如果当前的遍历位于一个嵌套的上下文环境，并且当前栈帧是嵌套栈帧的结束</span><br><span class="line">                    // 清楚嵌套上下文环境 和嵌套异常标记。</span><br><span class="line">                    if (NestedFrame == EstablisherFrame) &#123;</span><br><span class="line">                        ExceptionFlags &amp;= (~EXCEPTION_NESTED_CALL);</span><br><span class="line">                        NestedFrame = 0;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //</span><br><span class="line">                    // Case on the handler disposition.</span><br><span class="line">                    // 返回值处理</span><br><span class="line">                    switch (Disposition) &#123;</span><br><span class="line">                        //</span><br><span class="line">                        // The disposition is to continue execution.</span><br><span class="line">                        //</span><br><span class="line">                        // If the exception is not continuable, then raise</span><br><span class="line">                        // the exception STATUS_NONCONTINUABLE_EXCEPTION.</span><br><span class="line">                        // Otherwise return exception handled.</span><br><span class="line">                        // 继续执行。如果异常时不可继续执行，则抛出STATUS_NONCONTINUABLE_EXCEPTION异常，否则返回异常被处理</span><br><span class="line">                    case ExceptionContinueExecution :</span><br><span class="line">                        if ((ExceptionFlags &amp; EXCEPTION_NONCONTINUABLE) != 0) &#123;</span><br><span class="line">                            RtlRaiseStatus(STATUS_NONCONTINUABLE_EXCEPTION);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            Completion = TRUE;</span><br><span class="line">                            goto DispatchExit;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        //</span><br><span class="line">                        // The disposition is to continue the search.</span><br><span class="line">                        //</span><br><span class="line">                        // Get next frame address and continue the search.</span><br><span class="line">                        // 如果是继续搜索，获取下一个栈帧地址，并且继续搜索</span><br><span class="line">                    case ExceptionContinueSearch :</span><br><span class="line">                        break;</span><br><span class="line"></span><br><span class="line">                        //</span><br><span class="line">                        // The disposition is nested exception.</span><br><span class="line">                        //</span><br><span class="line">                        // Set the nested context frame to the establisher frame</span><br><span class="line">                        // address and set the nested exception flag in the</span><br><span class="line">                        // exception flags.</span><br><span class="line">                        // 如果返回值是一个嵌套异常，将嵌套上下文栈帧设置到建立者栈帧地址，并且在异常标记中设置嵌套标记</span><br><span class="line">                    case ExceptionNestedException :</span><br><span class="line">                        ExceptionFlags |= EXCEPTION_NESTED_CALL;</span><br><span class="line">                        if (DispatcherContext.EstablisherFrame &gt; NestedFrame) &#123;</span><br><span class="line">                            NestedFrame = DispatcherContext.EstablisherFrame;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line"></span><br><span class="line">                        //</span><br><span class="line">                        // The dispostion is collided unwind.</span><br><span class="line">                        //</span><br><span class="line">                        // A collided unwind occurs when an exception dispatch</span><br><span class="line">                        // encounters a previous call to an unwind handler. In</span><br><span class="line">                        // this case the previous unwound frames must be skipped.</span><br><span class="line">                        // 出现了异常冲突。如果异常分发遇到了对前一个展开处理的调用，则发生了展开冲突。</span><br><span class="line">                        // 这种情况下先前的展开帧必须跳过</span><br><span class="line">                    case ExceptionCollidedUnwind:</span><br><span class="line">                        ControlPc = DispatcherContext.ControlPc;</span><br><span class="line">                        ImageBase = DispatcherContext.ImageBase;</span><br><span class="line">                        FunctionEntry = DispatcherContext.FunctionEntry;</span><br><span class="line">                        EstablisherFrame = DispatcherContext.EstablisherFrame;</span><br><span class="line">                        RtlpCopyContext(&amp;ContextRecord1,</span><br><span class="line">                                        DispatcherContext.ContextRecord);</span><br><span class="line"></span><br><span class="line">                        ContextRecord1.Rip = ControlPc;</span><br><span class="line">                        ExceptionRoutine = DispatcherContext.LanguageHandler;</span><br><span class="line">                        HandlerData = DispatcherContext.HandlerData;</span><br><span class="line">                        HistoryTable = DispatcherContext.HistoryTable;</span><br><span class="line">                        ScopeIndex = DispatcherContext.ScopeIndex;</span><br><span class="line">                        Repeat = TRUE;</span><br><span class="line">                        break;</span><br><span class="line"></span><br><span class="line">                        //</span><br><span class="line">                        // All other disposition values are invalid.</span><br><span class="line">                        //</span><br><span class="line">                        // Raise invalid disposition exception.</span><br><span class="line">                        // 其他的返回值都被认为是无效的，发起无效异常处理</span><br><span class="line">                    default :</span><br><span class="line">                        RtlRaiseStatus(STATUS_INVALID_DISPOSITION);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; while (Repeat != FALSE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            //</span><br><span class="line">            // If the old control PC is the same as the return address,</span><br><span class="line">            // then no progress is being made and the function tables are</span><br><span class="line">            // most likely malformed.</span><br><span class="line">            // 如果老的控制PC 和当前的返回值相同，那么可能函数表最可能被破坏掉了</span><br><span class="line">            if (ControlPc == *(PULONG64)(ContextRecord1.Rsp)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //</span><br><span class="line">            // Set the point where control left the current function by</span><br><span class="line">            // obtaining the return address from the top of the stack.</span><br><span class="line">            // 这种情况可能是页函数，需要通过从栈顶获取返回值，将控制回到上一层函数。即非叶函数中。</span><br><span class="line">            ContextRecord1.Rip = *(PULONG64)(ContextRecord1.Rsp);</span><br><span class="line">            ContextRecord1.Rsp += 8;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        // Set point at which control left the previous routine.</span><br><span class="line">        // 进入上一层函数调用栈帧，继续搜索异常处理器</span><br><span class="line">        ControlPc = ContextRecord1.Rip;</span><br><span class="line">    &#125; while (RtlpIsFrameInBounds(&amp;LowLimit, (ULONG64)ContextRecord1.Rsp, &amp;HighLimit) == TRUE);</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Set final exception flags and return exception not handled.</span><br><span class="line">    // 设置最后的异常标记，返回异常没有处理。</span><br><span class="line">    ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Call vectored continue handlers.</span><br><span class="line">    //</span><br><span class="line">DispatchExit:</span><br><span class="line"></span><br><span class="line">    return Completion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下上述的函数的执行过程，首先获取栈界限以及异常地址等信息，寻找该异常地址对应的异常函数表中表项。如果当前函数为叶函数，则回退到它的调用函数中（对应的ControlPC也需要修改），再继续搜索异常函数表中表项。如果找到了异常函数表表项，则对当前的函数栈帧进行虚拟展开，获取异常处理函数（语言相关的处理函数 __C_specific_handler）。获取到异常处理函数之后，则调用该异常处理函数，根据返回值确定是否继续搜索异常处理器，还是继续执行程序。</p>
<p>关于异常处理的内容在下一节做简单总结，下面对X64上独有的这个RtlVirtualUnwind()函数做一个简单分析。同样适用WRK中的源代码为依据，RtlVirtualUnwind()函数代码如下代码块所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br></pre></td><td class="code"><pre><span class="line">/*++</span><br><span class="line">Routine Description:</span><br><span class="line">    This function virtually unwinds the specified function by executing its</span><br><span class="line">    prologue code backward or its epilogue code forward.</span><br><span class="line"></span><br><span class="line">    If a context pointers record is specified, then the address where each</span><br><span class="line">    nonvolatile registers is restored from is recorded in the appropriate</span><br><span class="line">    element of the context pointers record.</span><br><span class="line">	这个函数通过反向执行prologue或正向执行epilogue来虚拟展开指定函数。如果指定了Context指针记录，</span><br><span class="line">    每一个非易失寄存器的地址记录在Context适当的元素记录中。</span><br><span class="line">Arguments:</span><br><span class="line">    HandlerType - Supplies the handler type expected for the virtual unwind.</span><br><span class="line">        This may be either an exception or an unwind handler.提供虚拟展开需要的异常处理类型，或者是异常或者是展开</span><br><span class="line"></span><br><span class="line">    ImageBase - Supplies the base address of the image that contains the</span><br><span class="line">        function being unwound. 被展开函数所在映像的基地址</span><br><span class="line"></span><br><span class="line">    ControlPc - Supplies the address where control left the specified</span><br><span class="line">        function. 控制离开特定函数的地址</span><br><span class="line"></span><br><span class="line">    FunctionEntry - Supplies the address of the function table entry for the</span><br><span class="line">        specified function. 特定函数的函数表项地址</span><br><span class="line"></span><br><span class="line">    ContextRecord - Supplies the address of a context record. 异常上下文记录的地址</span><br><span class="line"></span><br><span class="line">    HandlerData - Supplies a pointer to a variable that receives a pointer</span><br><span class="line">        the the language handler data. 指向语言异常处理数据的指针</span><br><span class="line"></span><br><span class="line">    EstablisherFrame - Supplies a pointer to a variable that receives the</span><br><span class="line">        the establisher frame pointer value. 指向建立栈帧的函数的栈帧指针</span><br><span class="line"></span><br><span class="line">    ContextPointers - Supplies an optional pointer to a context pointers</span><br><span class="line">        record.	可选参数，指向非易失上下文记录的指针。</span><br><span class="line"></span><br><span class="line">Return Value:</span><br><span class="line">    If control did not leave the specified function in either the prologue</span><br><span class="line">    or an epilogue and a handler of the proper type is associated with the</span><br><span class="line">    function, then the address of the language specific exception handler</span><br><span class="line">    is returned. Otherwise, NULL is returned.</span><br><span class="line">--*/</span><br><span class="line">PEXCEPTION_ROUTINE RtlVirtualUnwind (</span><br><span class="line">    IN ULONG HandlerType,</span><br><span class="line">    IN ULONG64 ImageBase,</span><br><span class="line">    IN ULONG64 ControlPc,</span><br><span class="line">    IN PRUNTIME_FUNCTION FunctionEntry,</span><br><span class="line">    IN OUT PCONTEXT ContextRecord,</span><br><span class="line">    OUT PVOID *HandlerData,</span><br><span class="line">    OUT PULONG64 EstablisherFrame,</span><br><span class="line">    IN OUT PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL )</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ULONG64 BranchBase;</span><br><span class="line">    ULONG64 BranchTarget;</span><br><span class="line">    LONG Displacement;</span><br><span class="line">    ULONG FrameRegister;</span><br><span class="line">    ULONG Index;</span><br><span class="line">    LOGICAL InEpilogue;</span><br><span class="line">    PULONG64 IntegerAddress;</span><br><span class="line">    PULONG64 IntegerRegister;</span><br><span class="line">    PUCHAR NextByte;</span><br><span class="line">    PRUNTIME_FUNCTION PrimaryFunctionEntry;</span><br><span class="line">    ULONG PrologOffset;</span><br><span class="line">    ULONG RegisterNumber;</span><br><span class="line">    PUNWIND_INFO UnwindInfo;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // If the specified function does not use a frame pointer, then the</span><br><span class="line">    // establisher frame is the contents of the stack pointer. This may</span><br><span class="line">    // not actually be the real establisher frame if control left the</span><br><span class="line">    // function from within the prologue. In this case the establisher</span><br><span class="line">    // frame may be not required since control has not actually entered</span><br><span class="line">    // the function and prologue entries cannot refer to the establisher</span><br><span class="line">    // frame before it has been established, i.e., if it has not been</span><br><span class="line">    // established, then no save unwind codes should be encountered during</span><br><span class="line">    // the unwind operation.</span><br><span class="line">    //</span><br><span class="line">    // If the specified function uses a frame pointer and control left the</span><br><span class="line">    // function outside of the prologue or the unwind information contains</span><br><span class="line">    // a chained information structure, then the establisher frame is the</span><br><span class="line">    // contents of the frame pointer.</span><br><span class="line">    //</span><br><span class="line">    // If the specified function uses a frame pointer and control left the</span><br><span class="line">    // function from within the prologue, then the set frame pointer unwind</span><br><span class="line">    // code must be looked up in the unwind codes to determine if the</span><br><span class="line">    // contents of the stack pointer or the contents of the frame pointer</span><br><span class="line">    // should be used for the establisher frame. This may not actually be</span><br><span class="line">    // the real establisher frame. In this case the establisher frame may</span><br><span class="line">    // not be required since control has not actually entered the function</span><br><span class="line">    // and prologue entries cannot refer to the establisher frame before it</span><br><span class="line">    // has been established, i.e., if it has not been established, then no</span><br><span class="line">    // save unwind codes should be encountered during the unwind operation.</span><br><span class="line">    //</span><br><span class="line">    // N.B. The correctness of these assumptions is based on the ordering of</span><br><span class="line">    //      unwind codes.</span><br><span class="line">    // 如果指定的函数没有使用帧指针，然后建立者帧就是栈指针中的内容。如果从之离开函数时</span><br><span class="line">    // 执行地址位于prologue中，那么这个栈指针可能不是真正的建立者栈帧。这种情况下，可能</span><br><span class="line">    // 不要求建立帧栈帧，因为控制并没有真正进入当前函数，并且prologue代码在栈帧建立起来</span><br><span class="line">    // 之前并没有引用建立者栈帧。也就是说，如果栈帧还没有被建立起来，在展开操作中不应该</span><br><span class="line">    // 碰到保存的展开代码。</span><br><span class="line">    //</span><br><span class="line">    // 如果指定的函数使用栈帧指针，并且执行控制（RIP）离开函数是在prologue之外，或展开</span><br><span class="line">    // 信息包含了链式信息结构，那么建立者栈帧就使用栈帧指针的内容。</span><br><span class="line">	//</span><br><span class="line">    // 如果指定函数使用了栈帧指针，并且控制离开函数时位于prologue中，那么设置帧指针的</span><br><span class="line">    // 展开代码必须从保存的展开代码中查找，确定是否栈指针或栈帧指针的内容应该用于建立帧栈帧。</span><br><span class="line">    // 这个内容也不一定是真实的建立者栈帧。这种情况下，不应该要求建立者栈帧，因为控制并没有</span><br><span class="line">    // 真正地进入到函数，并且在栈帧建立之前，prologue条目都不能引用建立者栈帧。也就是说，</span><br><span class="line">    // 如果栈帧没有建立起来，在展开操作中不应该用到保存的展开代码。</span><br><span class="line">    //</span><br><span class="line">    // 这些对应的假设是基于展开代码顺序的。</span><br><span class="line">    //</span><br><span class="line">    UnwindInfo = (PUNWIND_INFO)(FunctionEntry-&gt;UnwindData + ImageBase);		// 展开数据</span><br><span class="line">    PrologOffset = (ULONG)(ControlPc - (FunctionEntry-&gt;BeginAddress + ImageBase));</span><br><span class="line">    if (UnwindInfo-&gt;FrameRegister == 0) &#123;</span><br><span class="line">        *EstablisherFrame = ContextRecord-&gt;Rsp;		// 没有指定栈帧指针，直接使用Rsp</span><br><span class="line"></span><br><span class="line">    &#125; else if ((PrologOffset &gt;= UnwindInfo-&gt;SizeOfProlog) ||</span><br><span class="line">               ((UnwindInfo-&gt;Flags &amp; UNW_FLAG_CHAININFO) != 0)) &#123;</span><br><span class="line">		// 发生异常的指令不在 Prolog范围中，则当前函数栈帧已经建立，就是上述第二种情况</span><br><span class="line">        *EstablisherFrame = (&amp;ContextRecord-&gt;Rax)[UnwindInfo-&gt;FrameRegister];</span><br><span class="line">        *EstablisherFrame -= UnwindInfo-&gt;FrameOffset * 16;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Index = 0;</span><br><span class="line">        while (Index &lt; UnwindInfo-&gt;CountOfCodes) &#123;</span><br><span class="line">            if (UnwindInfo-&gt;UnwindCode[Index].UnwindOp == UWOP_SET_FPREG) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Index += 1;</span><br><span class="line">        &#125;</span><br><span class="line">		// 如果指令已经将构建栈帧的指令执行完了，则要按照帧指针即偏移计算帧指针，否则直接用RSP做帧指针</span><br><span class="line">        if (PrologOffset &gt;= UnwindInfo-&gt;UnwindCode[Index].CodeOffset) &#123;</span><br><span class="line">            *EstablisherFrame = (&amp;ContextRecord-&gt;Rax)[UnwindInfo-&gt;FrameRegister];</span><br><span class="line">            *EstablisherFrame -= UnwindInfo-&gt;FrameOffset * 16;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            *EstablisherFrame = ContextRecord-&gt;Rsp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // If the point at which control left the specified function is in an</span><br><span class="line">    // epilogue, then emulate the execution of the epilogue forward and</span><br><span class="line">    // return no exception handler.</span><br><span class="line">    // 如果控制离开指定函数时位于epilogue中，要将epilogue执行完，返回到调用函数中</span><br><span class="line"></span><br><span class="line">    IntegerRegister = &amp;ContextRecord-&gt;Rax;</span><br><span class="line">    NextByte = (PUCHAR)ControlPc;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Check for one of:	// X64的epilogue做了优化，只有如下几种情况，修改RSP。再就是非易失寄存器的恢复</span><br><span class="line">    //</span><br><span class="line">    //   add rsp, imm8</span><br><span class="line">    //       or</span><br><span class="line">    //   add rsp, imm32</span><br><span class="line">    //       or</span><br><span class="line">    //   lea rsp, -disp8[fp]</span><br><span class="line">    //       or</span><br><span class="line">    //   lea rsp, -disp32[fp]</span><br><span class="line">    //</span><br><span class="line"></span><br><span class="line">    if ((NextByte[0] == SIZE64_PREFIX) &amp;&amp;</span><br><span class="line">        (NextByte[1] == ADD_IMM8_OP) &amp;&amp;</span><br><span class="line">        (NextByte[2] == 0xc4)) &#123;</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        // add rsp, imm8.</span><br><span class="line">        //</span><br><span class="line"></span><br><span class="line">        NextByte += 4;</span><br><span class="line"></span><br><span class="line">    &#125; else if ((NextByte[0] == SIZE64_PREFIX) &amp;&amp;</span><br><span class="line">               (NextByte[1] == ADD_IMM32_OP) &amp;&amp;</span><br><span class="line">               (NextByte[2] == 0xc4)) &#123;</span><br><span class="line">        //</span><br><span class="line">        // add rsp, imm32.</span><br><span class="line">        //</span><br><span class="line">        NextByte += 7;</span><br><span class="line">    &#125; else if (((NextByte[0] &amp; 0xfe) == SIZE64_PREFIX) &amp;&amp;</span><br><span class="line">               (NextByte[1] == LEA_OP)) &#123;</span><br><span class="line"></span><br><span class="line">        FrameRegister = ((NextByte[0] &amp; 0x1) &lt;&lt; 3) | (NextByte[2] &amp; 0x7);</span><br><span class="line">        if ((FrameRegister != 0) &amp;&amp;</span><br><span class="line">            (FrameRegister == UnwindInfo-&gt;FrameRegister)) &#123;</span><br><span class="line"></span><br><span class="line">            if ((NextByte[2] &amp; 0xf8) == 0x60) &#123;</span><br><span class="line">                //</span><br><span class="line">                // lea rsp, disp8[fp].</span><br><span class="line">                //</span><br><span class="line">                NextByte += 4;</span><br><span class="line">            &#125; else if ((NextByte[2] &amp;0xf8) == 0xa0) &#123;</span><br><span class="line">                //</span><br><span class="line">                // lea rsp, disp32[fp].</span><br><span class="line">                //</span><br><span class="line">                NextByte += 7;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Check for any number of:</span><br><span class="line">    //</span><br><span class="line">    //   pop nonvolatile-integer-register[0..15].</span><br><span class="line">    //	弹出栈上的非易失寄存器(这块并没有弹出而是仅仅查找函数结尾的return/jmp指令)</span><br><span class="line"></span><br><span class="line">    while (TRUE) &#123;</span><br><span class="line">        if ((NextByte[0] &amp; 0xf8) == POP_OP) &#123;</span><br><span class="line">            NextByte += 1;</span><br><span class="line"></span><br><span class="line">        &#125; else if (IS_REX_PREFIX(NextByte[0]) &amp;&amp;</span><br><span class="line">                   ((NextByte[1] &amp; 0xf8) == POP_OP)) &#123;</span><br><span class="line"></span><br><span class="line">            NextByte += 2;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // If the next instruction is a return or an appropriate jump, then</span><br><span class="line">    // control is currently in an epilogue and execution of the epilogue</span><br><span class="line">    // should be emulated. Otherwise, execution is not in an epilogue and</span><br><span class="line">    // the prologue should be unwound.</span><br><span class="line">    // 如果处理完非易失性寄存器的操作代码后，后面是return或适当的jump，则异常指令位于epilogue中</span><br><span class="line">    // 直接将epilogue模拟执行完毕，否则要将prologue模拟展开</span><br><span class="line"></span><br><span class="line">    InEpilogue = FALSE;</span><br><span class="line">    if ((NextByte[0] == RET_OP) ||</span><br><span class="line">        (NextByte[0] == RET_OP_2) ||</span><br><span class="line">        ((NextByte[0] == REP_PREFIX) &amp;&amp; (NextByte[1] == RET_OP))) &#123;</span><br><span class="line">        //</span><br><span class="line">        // A return is an unambiguous indication of an epilogue. 返回指令确定无疑是位于epilogue中</span><br><span class="line">        //</span><br><span class="line">        InEpilogue = TRUE;</span><br><span class="line">    &#125; else if ((NextByte[0] == JMP_IMM8_OP) || (NextByte[0] == JMP_IMM32_OP)) &#123;</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        // An unconditional branch to a target that is equal to the start of</span><br><span class="line">        // or outside of this routine is logically a call to another function.</span><br><span class="line">        // 非条件分支，跳转到另外一个函数起始或当前函数外部 逻辑上讲是对其他函数的调用</span><br><span class="line"></span><br><span class="line">        BranchTarget = (ULONG64)NextByte - ImageBase;</span><br><span class="line">        if (NextByte[0] == JMP_IMM8_OP) &#123;</span><br><span class="line">            BranchTarget += 2 + (CHAR)NextByte[1];</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            BranchTarget += 5 + *((LONG UNALIGNED *)&amp;NextByte[1]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        // Determine whether the branch target refers to code within this</span><br><span class="line">        // function. If not, then it is an epilogue indicator.</span><br><span class="line">        //</span><br><span class="line">        // A branch to the start of self implies a recursive call, so</span><br><span class="line">        // is treated as an epilogue.</span><br><span class="line">        // 确定是否分支目标指向当前这个函数，如果不指向当前函数则表明是epilogue代码</span><br><span class="line">        // 跳转函数自己开始处意味着递归调用，所以也当作epilogue处理</span><br><span class="line">        if (BranchTarget &lt; FunctionEntry-&gt;BeginAddress ||</span><br><span class="line">            BranchTarget &gt;= FunctionEntry-&gt;EndAddress) &#123;</span><br><span class="line"></span><br><span class="line">            //</span><br><span class="line">            // The branch target is outside of the region described by</span><br><span class="line">            // this function entry. See whether it is contained within</span><br><span class="line">            // an indirect function entry associated with this same</span><br><span class="line">            // function.</span><br><span class="line">            //</span><br><span class="line">            // If not, then the branch target really is outside of</span><br><span class="line">            // this function.</span><br><span class="line">            //</span><br><span class="line">			// 判断跳转的目标和当前函数是否同一个</span><br><span class="line">            PrimaryFunctionEntry = RtlpSameFunction(FunctionEntry,</span><br><span class="line">                                                    ImageBase,</span><br><span class="line">                                                    BranchTarget + ImageBase);</span><br><span class="line"></span><br><span class="line">			// 对于并非同一个，或是同一个函数但是是函数起始位置（递归了），则也是位于Epilogue</span><br><span class="line">            if ((PrimaryFunctionEntry == NULL) ||</span><br><span class="line">                (BranchTarget == PrimaryFunctionEntry-&gt;BeginAddress)) &#123;</span><br><span class="line"></span><br><span class="line">                InEpilogue = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else if ((BranchTarget == FunctionEntry-&gt;BeginAddress) &amp;&amp;</span><br><span class="line">                   ((UnwindInfo-&gt;Flags &amp; UNW_FLAG_CHAININFO) == 0)) &#123;</span><br><span class="line">			// 递归了，并且没有CHAININFO，则认为是位于Epilogue</span><br><span class="line">            InEpilogue = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else if ((NextByte[0] == JMP_IND_OP) &amp;&amp; (NextByte[1] == 0x25)) &#123;</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        // An unconditional jump indirect.</span><br><span class="line">        //</span><br><span class="line">        // This is a jmp outside of the function, probably a tail call</span><br><span class="line">        // to an import function.</span><br><span class="line">        // 非条件的间接跳转</span><br><span class="line">        InEpilogue = TRUE;</span><br><span class="line">    &#125; else if (((NextByte[0] &amp; 0xf8) == SIZE64_PREFIX) &amp;&amp;</span><br><span class="line">               (NextByte[1] == 0xff) &amp;&amp;</span><br><span class="line">               (NextByte[2] &amp; 0x38) == 0x20) &#123;</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        // This is an indirect jump opcode: 0x48 0xff /4.  The 64-bit</span><br><span class="line">        // flag (REX.W) is always redundant here, so its presence is</span><br><span class="line">        // overloaded to indicate a branch out of the function - a tail</span><br><span class="line">        // call.</span><br><span class="line">        //</span><br><span class="line">        // Such an opcode is an unambiguous epilogue indication.</span><br><span class="line">        // 间接跳转，64位标识被省略，尾部调用。要跳转出当前函数，必然当前位置位于epilogue</span><br><span class="line"></span><br><span class="line">        InEpilogue = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">	// 对于在Epilogue的情况来说，需要先将epilogue模拟执行完毕。</span><br><span class="line">    // 依次是将分配栈帧回退掉，恢复非易失寄存器，根据jump/return找到返回地址</span><br><span class="line">    if (InEpilogue != FALSE) &#123;</span><br><span class="line">        NextByte = (PUCHAR)ControlPc;</span><br><span class="line">        //</span><br><span class="line">        // Emulate one of (if any):</span><br><span class="line">        //</span><br><span class="line">        //   add rsp, imm8</span><br><span class="line">        //       or</span><br><span class="line">        //   add rsp, imm32</span><br><span class="line">        //       or</span><br><span class="line">        //   lea rsp, disp8[frame-register]</span><br><span class="line">        //       or</span><br><span class="line">        //   lea rsp, disp32[frame-register]</span><br><span class="line">        //</span><br><span class="line">        if ((NextByte[0] &amp; 0xf8) == SIZE64_PREFIX) &#123;</span><br><span class="line">            if (NextByte[1] == ADD_IMM8_OP) &#123;</span><br><span class="line">                //</span><br><span class="line">                // add rsp, imm8.</span><br><span class="line">                //</span><br><span class="line">                ContextRecord-&gt;Rsp += (CHAR)NextByte[3];</span><br><span class="line">                NextByte += 4;</span><br><span class="line">            &#125; else if (NextByte[1] == ADD_IMM32_OP) &#123;</span><br><span class="line">                //</span><br><span class="line">                // add rsp, imm32.</span><br><span class="line">                //</span><br><span class="line">                Displacement = NextByte[3] | (NextByte[4] &lt;&lt; 8);</span><br><span class="line">                Displacement |= (NextByte[5] &lt;&lt; 16) | (NextByte[6] &lt;&lt; 24);</span><br><span class="line">                ContextRecord-&gt;Rsp += Displacement;</span><br><span class="line">                NextByte += 7;</span><br><span class="line">            &#125; else if (NextByte[1] == LEA_OP) &#123;</span><br><span class="line">                if ((NextByte[2] &amp; 0xf8) == 0x60) &#123;</span><br><span class="line">                    //</span><br><span class="line">                    // lea rsp, disp8[frame-register].</span><br><span class="line">                    //</span><br><span class="line">                    ContextRecord-&gt;Rsp = IntegerRegister[FrameRegister];</span><br><span class="line">                    ContextRecord-&gt;Rsp += (CHAR)NextByte[3];</span><br><span class="line">                    NextByte += 4;</span><br><span class="line">                &#125; else if ((NextByte[2] &amp; 0xf8) == 0xa0) &#123;</span><br><span class="line">                    //</span><br><span class="line">                    // lea rsp, disp32[frame-register].</span><br><span class="line">                    //</span><br><span class="line">                    Displacement = NextByte[3] | (NextByte[4] &lt;&lt; 8);</span><br><span class="line">                    Displacement |= (NextByte[5] &lt;&lt; 16) | (NextByte[6] &lt;&lt; 24);</span><br><span class="line">                    ContextRecord-&gt;Rsp = IntegerRegister[FrameRegister];</span><br><span class="line">                    ContextRecord-&gt;Rsp += Displacement;</span><br><span class="line">                    NextByte += 7;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        // Emulate any number of (if any):</span><br><span class="line">        //</span><br><span class="line">        //   pop nonvolatile-integer-register.</span><br><span class="line">        //   弹出非易失整数寄存器（RBP/RBX等）</span><br><span class="line">        while (TRUE) &#123;</span><br><span class="line">            if ((NextByte[0] &amp; 0xf8) == POP_OP) &#123;</span><br><span class="line">                //</span><br><span class="line">                // pop nonvolatile-integer-register[0..7]</span><br><span class="line">                //</span><br><span class="line">                RegisterNumber = NextByte[0] &amp; 0x7;</span><br><span class="line">                IntegerAddress = (PULONG64)ContextRecord-&gt;Rsp;</span><br><span class="line">                IntegerRegister[RegisterNumber] = *IntegerAddress;</span><br><span class="line">                if (ARGUMENT_PRESENT(ContextPointers)) &#123;</span><br><span class="line">                    ContextPointers-&gt;IntegerContext[RegisterNumber] = IntegerAddress;</span><br><span class="line">                &#125;</span><br><span class="line">                ContextRecord-&gt;Rsp += 8;</span><br><span class="line">                NextByte += 1;</span><br><span class="line">            &#125; else if (IS_REX_PREFIX(NextByte[0]) &amp;&amp; ((NextByte[1] &amp; 0xf8) == POP_OP)) &#123;</span><br><span class="line">                //</span><br><span class="line">                // pop nonvolatile-integer-register[8..15]</span><br><span class="line">                //</span><br><span class="line">                RegisterNumber = ((NextByte[0] &amp; 1) &lt;&lt; 3) | (NextByte[1] &amp; 0x7);</span><br><span class="line">                IntegerAddress = (PULONG64)ContextRecord-&gt;Rsp;</span><br><span class="line">                IntegerRegister[RegisterNumber] = *IntegerAddress;</span><br><span class="line">                if (ARGUMENT_PRESENT(ContextPointers)) &#123;</span><br><span class="line">                    ContextPointers-&gt;IntegerContext[RegisterNumber] = IntegerAddress;</span><br><span class="line">                &#125;</span><br><span class="line">                ContextRecord-&gt;Rsp += 8;</span><br><span class="line">                NextByte += 2;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        // Emulate return and return null exception handler.</span><br><span class="line">        //</span><br><span class="line">        // Note: this instruction might in fact be a jmp, however</span><br><span class="line">        //       we want to emulate a return regardless.</span><br><span class="line">        // 注意这块的指令或许是jmp，但是我们是想要模拟一个return</span><br><span class="line">        ContextRecord-&gt;Rip = *(PULONG64)(ContextRecord-&gt;Rsp);</span><br><span class="line">        ContextRecord-&gt;Rsp += 8;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Control left the specified function outside an epilogue. Unwind the</span><br><span class="line">    // subject function and any chained unwind information.</span><br><span class="line">    // 控制是从指定函数的epilogue之外返回，那么就要展开目标函数和任意链接展开信息</span><br><span class="line">    FunctionEntry = RtlpUnwindPrologue(ImageBase,</span><br><span class="line">                                       ControlPc,</span><br><span class="line">                                       *EstablisherFrame,</span><br><span class="line">                                       FunctionEntry,</span><br><span class="line">                                       ContextRecord,</span><br><span class="line">                                       ContextPointers);</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // If control left the specified function outside of the prologue and</span><br><span class="line">    // the function has a handler that matches the specified type, then</span><br><span class="line">    // return the address of the language specific exception handler.</span><br><span class="line">    // Otherwise, return NULL.</span><br><span class="line">    // 如果控制是从指定函数prologue之外离开，并且函数有异常处理器符合本次异常类型，</span><br><span class="line">    // 那么就返回语言特定异常处理函数（__C_except_handler），否则返回NULL</span><br><span class="line">    UnwindInfo = (PUNWIND_INFO)(FunctionEntry-&gt;UnwindData + ImageBase);</span><br><span class="line">    PrologOffset = (ULONG)(ControlPc - (FunctionEntry-&gt;BeginAddress + ImageBase));</span><br><span class="line">    if ((PrologOffset &gt;= UnwindInfo-&gt;SizeOfProlog) &amp;&amp;</span><br><span class="line">        ((UnwindInfo-&gt;Flags &amp; HandlerType) != 0)) &#123;</span><br><span class="line">        Index = UnwindInfo-&gt;CountOfCodes;</span><br><span class="line">        if ((Index &amp; 1) != 0) &#123;</span><br><span class="line">            Index += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *HandlerData = &amp;UnwindInfo-&gt;UnwindCode[Index + 2];	// +2 绕过DWORD，即__C_specific_handler，找到ScopeTable</span><br><span class="line">        return (PEXCEPTION_ROUTINE)(*((PULONG)&amp;UnwindInfo-&gt;UnwindCode[Index]) + ImageBase);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下上面这个函数，做虚拟展开是为了寻找匹配的异常处理函数，并且获取到可以调用异常处理函数的Context信息，以便于调用异常处理函数。根据发生异常的位置（调用发生异常函数的位置），确定是否位于prologue/epilogue，或者位于函数真正逻辑代码中，对他们分别进行不同处理。对于位于prologue的情况要将已经执行的代码模拟回退掉；对于位于函数真正逻辑中的情况要将整个prologue回退掉；对于位于epilogue的情况，则只需要将剩余代码模拟执行完毕，退到调用它的函数位置即可。对于prologue和epilogue的模拟比较简单，他们的指令都是固定集中，做对应后对RSP和非可变寄存器操作即可。</p>
<p>在这个函数中调用了两个函数，RtlpSameFunction和RtlpUnwindPrologue。两个函数也不是特别难理解，理解了上述两个函数，他们应该都不是什么问题。对于想要了解prologue和epilogue的模拟执行的，可以研究一下RtlpunwindPrologue（）函数。</p>
<p>从上面的代码中可以看到，RtlDispatchException负责遍历X64模块“注册”的异常列表；对于每一个函数的异常表项调用RtlVirtualUnwind()进行模拟展开，获取该函数对应的异常处理函数地址以及异常信息表（ScopeTable）；如果有异常处理函数，则有RtlDispatchException调用异常处理函数过滤是否可以处理当前异常；如果没有异常函数，根据虚拟展开后的Context中Rip确定当前函数的返回地址，进一步循环异常表。通过上述一系列动作，就完成了异常列表的遍历与异常函数调用。</p>
<p>那么下面内容就明显了，就是调用异常处理函数了。在前面总结异常信息注册时，为SehTest函数的注册的异常处理函数即<code>__C_specific_handler</code>函数（其实所有的异常处理函数都是这个函数），下面一节简要分析一下这个函数。</p>
<h3 id="异常处理和堆栈展开"><a href="#异常处理和堆栈展开" class="headerlink" title="异常处理和堆栈展开"></a>异常处理和堆栈展开</h3><p>在RtlDispatchException()函数中对异常处理函数的调用是通过RtlpExecuteHandlerForException()间接完成的，它只是做了一个”中继”，没有额外内容，不再看它了，直接来看<code>_C_specific_handler</code>函数。</p>
<p>从WRK中也没发现<code>_C_specific_handler</code>函数的定义，应该是被编译为lib进行链接了。这里将SehTest中该函数的逆向代码放在这里，下面就对这段代码做简单分析，用于了解异常处理的过程。在分析该函数之前，先看一个结构体<code>DISPATCHER_CONTEXT</code>，它的内容如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _DISPATCHER_CONTEXT &#123;</span><br><span class="line">    ULONG64               ControlPc;			// 虚拟展开后的当前IP</span><br><span class="line">    ULONG64               ImageBase;			// 映像基地址</span><br><span class="line">    PRUNTIME_FUNCTION     FunctionEntry;		// 运行时函数表，注册的异常处理信息</span><br><span class="line">    ULONG64               EstablisherFrame;		// 当前ControlPC对应栈帧</span><br><span class="line">    ULONG64               TargetIp;				// 展开中ScopeTable遍历的终止条件</span><br><span class="line">    PCONTEXT              ContextRecord;		// 虚拟展开中获取的ControlPC的运行时上下文</span><br><span class="line">    PEXCEPTION_ROUTINE    LanguageHandler;		// _C_specific_handler</span><br><span class="line">    PVOID                 HandlerData;			// ScopeTable</span><br><span class="line">    PUNWIND_HISTORY_TABLE HistoryTable;			// 历史表，加速函数表搜索</span><br><span class="line">    ULONG                 ScopeIndex;			// Sopetable索引下表</span><br><span class="line">    ULONG                 Fill0;				// 暂无用</span><br><span class="line">&#125; DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception</span><br><span class="line">#define EXCEPTION_UNWINDING 0x2         // Unwind is in progress</span><br><span class="line">#define EXCEPTION_EXIT_UNWIND 0x4       // Exit unwind is in progress</span><br><span class="line">#define EXCEPTION_STACK_INVALID 0x8     // Stack out of limits or unaligned</span><br><span class="line">#define EXCEPTION_NESTED_CALL 0x10      // Nested exception handler call</span><br><span class="line">#define EXCEPTION_TARGET_UNWIND 0x20    // Target unwind in progress</span><br><span class="line">#define EXCEPTION_COLLIDED_UNWIND 0x40  // Collided exception handler call</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 __fastcall _C_specific_handler(_EXCEPTION_RECORD *ExceptionRecord,</span><br><span class="line">											  void *EstablisherFrame,</span><br><span class="line">                                              _CONTEXT *ContextRecord,</span><br><span class="line">                                              _DISPATCHER_CONTEXT *DispatcherContext)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 ImageBase; // r15@1</span><br><span class="line">  unsigned int *pHandlerData; // rsi@1</span><br><span class="line">  unsigned __int64 ContorlOffset; // r12@1</span><br><span class="line">  _DISPATCHER_CONTEXT *pDispatcherContext; // r14@1</span><br><span class="line">  void *pEstablisherFrame; // rbp@1</span><br><span class="line">  _EXCEPTION_RECORD *pExceptionRecord; // r13@1</span><br><span class="line">  unsigned int ScopeTableIndex; // edi@2</span><br><span class="line">  signed __int64 pFilterFunc; // rbx@3</span><br><span class="line">  int nResult; // eax@8</span><br><span class="line">  unsigned int v14; // ebp@18</span><br><span class="line">  unsigned __int64 TargetIpOffset; // rdi@18</span><br><span class="line">  _DWORD *pScopeTable_ItemJumpTarget; // rbx@19</span><br><span class="line">  unsigned __int64 rvaBeginAddress; // rcx@20</span><br><span class="line">  unsigned __int64 rvaEndAddress; // rax@21</span><br><span class="line">  _EXCEPTION_RECORD *pExceptionRecord1; // [sp+30h] [bp-38h]@2</span><br><span class="line">  _CONTEXT *pContextRecord1; // [sp+38h] [bp-30h]@2</span><br><span class="line">  void *v21; // [sp+78h] [bp+10h]@1</span><br><span class="line"></span><br><span class="line">  v21 = EstablisherFrame;</span><br><span class="line">  ImageBase = DispatcherContext-&gt;ImageBase;</span><br><span class="line">  pHandlerData = (unsigned int *)DispatcherContext-&gt;HandlerData;// _SCOPE_TABLE</span><br><span class="line">  ContorlOffset = DispatcherContext-&gt;ControlPc - ImageBase;</span><br><span class="line">  pDispatcherContext = DispatcherContext;</span><br><span class="line">  pEstablisherFrame = EstablisherFrame;</span><br><span class="line">  pExceptionRecord = ExceptionRecord;</span><br><span class="line">  if ( ExceptionRecord-&gt;ExceptionFlags &amp; 0x66 ) // pExceptionRecord-&gt;ExceptionFlags &amp; EXCEPTION_UNWIND，判断是否展开过程</span><br><span class="line">  &#123;</span><br><span class="line">    v14 = 0;</span><br><span class="line">    TargetIpOffset = DispatcherContext-&gt;TargetIp - ImageBase;</span><br><span class="line">    if ( *pHandlerData )</span><br><span class="line">    &#123;</span><br><span class="line">      pScopeTable_ItemJumpTarget = pHandlerData + 4;</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">        rvaBeginAddress = *(pScopeTable_ItemJumpTarget - 3);// BeginAddress</span><br><span class="line">        if ( ContorlOffset &gt;= rvaBeginAddress )</span><br><span class="line">        &#123;</span><br><span class="line">          rvaEndAddress = *(pScopeTable_ItemJumpTarget - 2);// EndAddress</span><br><span class="line">          if ( ContorlOffset &lt; rvaEndAddress )</span><br><span class="line">          &#123;</span><br><span class="line">            if ( TargetIpOffset &gt;= rvaBeginAddress</span><br><span class="line">              &amp;&amp; TargetIpOffset &lt; rvaEndAddress</span><br><span class="line">              &amp;&amp; pExceptionRecord-&gt;ExceptionFlags &amp; 0x20 )	// 到了目的地址，即展开的终点</span><br><span class="line">            &#123;</span><br><span class="line">              return 1i64;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ( *pScopeTable_ItemJumpTarget )		// 表示当前为 __try/__except 块</span><br><span class="line">            &#123;</span><br><span class="line">			  // 当前的ExceptHandler块的地址就是将要执行的ExceptHandler的地址，直接返回找到了目标块即可</span><br><span class="line">			  // 这是本次展开操作的终点</span><br><span class="line">              if ( TargetIpOffset == *pScopeTable_ItemJumpTarget )</span><br><span class="line">                return 1i64;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">			  // 当前为__try/__finally 块</span><br><span class="line">			  // 将Dispatcher_Context-&gt;ScopeIndex ++ ，越过这个__try/__finally</span><br><span class="line">			  // 在执行此finally 的时候产生异常并被捕获后，展开将继续执行，并越过这个finally块。</span><br><span class="line">              LOBYTE(rvaBeginAddress) = 1;</span><br><span class="line">              pDispatcherContext-&gt;ControlPc = ImageBase + rvaEndAddress;</span><br><span class="line">              ((void (__fastcall *)(unsigned __int64, void *))(ImageBase + *(pScopeTable_ItemJumpTarget - 1)))(</span><br><span class="line">                rvaBeginAddress,</span><br><span class="line">                v21);                           // 调用HandlerAddress指向的函数</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++v14;                                  // 遍历计数</span><br><span class="line">        pScopeTable_ItemJumpTarget += 4;        // ScopeTable的下一个Item</span><br><span class="line">      &#125;</span><br><span class="line">      while ( v14 &lt; *pHandlerData );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else                                          // 异常处理</span><br><span class="line">  &#123;</span><br><span class="line">	/**</span><br><span class="line">	* 异常操作相对比较简单，遍历SCOPE_TABLE 中的SCOPE_ENTRY 数组，依次寻找包含目标代码的__try/__except 块，并执行其filter 函数</span><br><span class="line">	* 根据filter 函数的返回值</span><br><span class="line">	* EXCEPTION_CONTINUE_EXECUTION 	直接返回 ExceptionContinueExecution</span><br><span class="line">	* EXCEPTION_EXECUTE_HANDLER 	调用RtlUnwindEx 执行handler 函数</span><br><span class="line">	* EXCEPTION_CONTINUE_SEARCH 	继续遍历</span><br><span class="line">	*/</span><br><span class="line">    ScopeTableIndex = 0;</span><br><span class="line">    pExceptionRecord1 = ExceptionRecord;</span><br><span class="line">    pContextRecord1 = ContextRecord;</span><br><span class="line">    if ( *pHandlerData )</span><br><span class="line">    &#123;</span><br><span class="line">      pFilterFunc = (signed __int64)(pHandlerData + 3);</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">        if ( ContorlOffset &gt;= *(_DWORD *)(pFilterFunc - 8)// BeginAddress</span><br><span class="line">          &amp;&amp; ContorlOffset &lt; *(_DWORD *)(pFilterFunc - 4)// EndAddress</span><br><span class="line">          &amp;&amp; *(_DWORD *)(pFilterFunc + 4) )     // JumpTarget</span><br><span class="line">        &#123;</span><br><span class="line">          if ( *(_DWORD *)pFilterFunc == 1 )    // EXCEPTION_EXECUTE_HANDLER = 1</span><br><span class="line">            goto LABEL_33;</span><br><span class="line">          nResult = ((int (__fastcall *)(_EXCEPTION_RECORD **, void *))(ImageBase + *(_DWORD *)pFilterFunc))(</span><br><span class="line">                      &amp;pExceptionRecord1,</span><br><span class="line">                      pEstablisherFrame);</span><br><span class="line">          if ( nResult &lt; 0 )                    // EXCEPTION_CONTINUE_EXECUTION = -1</span><br><span class="line">            return 0i64;</span><br><span class="line">          if ( nResult &gt; 0 )</span><br><span class="line">          &#123;</span><br><span class="line">LABEL_33:</span><br><span class="line">            if ( pExceptionRecord-&gt;ExceptionCode == 0xE06D7363 &amp;&amp; *(_QWORD *)pDestructExceptionObject )</span><br><span class="line">            &#123;</span><br><span class="line">              if ( IsNonwritableInCurrentImage(pDestructExceptionObject) )</span><br><span class="line">                ((void (__fastcall *)(_EXCEPTION_RECORD *, signed __int64))pDestructExceptionObject)(</span><br><span class="line">                  pExceptionRecord,</span><br><span class="line">                  1i64);</span><br><span class="line">            &#125;</span><br><span class="line">            NLG_Notify(ImageBase + *(_DWORD *)(pFilterFunc + 4), pEstablisherFrame, 1i64);</span><br><span class="line">            RtlUnwindEx(</span><br><span class="line">              pEstablisherFrame,</span><br><span class="line">              (PVOID)(ImageBase + *(_DWORD *)(pFilterFunc + 4)),</span><br><span class="line">              pExceptionRecord,</span><br><span class="line">              (PVOID)pExceptionRecord-&gt;ExceptionCode,</span><br><span class="line">              pDispatcherContext-&gt;ContextRecord,</span><br><span class="line">              pDispatcherContext-&gt;HistoryTable);</span><br><span class="line">            _NLG_Return2();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ScopeTableIndex;                      // EXCEPTION_CONTINUE_SEARCH = 0 继续循环</span><br><span class="line">        pFilterFunc += 16i64;                   // 循环ScopeTable下一个表项</span><br><span class="line">      &#125;</span><br><span class="line">      while ( ScopeTableIndex &lt; *pHandlerData );// Index不超过表大小</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 1i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参照X86中的异常处理函数逻辑，该函数也是类似逻辑。分两种情况（说明在异常处理时会两次进入），一种是异常处理时进入该函数中遍历ScopeTable，并按照是否有Filter函数，如果有则调用该函数，返回异常可以被处理（即1），则进入异常展开阶段；否则继续遍历ScopeTable直到找到可以处理项或到结尾。第二次进入该函数是展开过程中，依然是遍历ScopeTable，确定是否到达了目标try语句，其中对于finally语句则直接调用。</p>
<p>在找到了可以处理当前异常的ScopeTable表项后，则调用 RtlUnwindEx()函数进行展开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line">/*++</span><br><span class="line">Routine Description:</span><br><span class="line">    This function initiates an unwind of procedure call frames. The machine</span><br><span class="line">    state at the time of the call to unwind is captured in a context record</span><br><span class="line">    and the unwinding flag is set in the exception flags of the exception</span><br><span class="line">    record. If the TargetFrame parameter is not specified, then the exit unwind</span><br><span class="line">    flag is also set in the exception flags of the exception record. A backward</span><br><span class="line">    scan through the procedure call frames is then performed to find the target</span><br><span class="line">    of the unwind operation.</span><br><span class="line"></span><br><span class="line">    As each frame is encounter, the PC where control left the corresponding</span><br><span class="line">    function is determined and used to lookup exception handler information</span><br><span class="line">    in the runtime function table built by the linker. If the respective</span><br><span class="line">    routine has an exception handler, then the handler is called.</span><br><span class="line">	这个函数发起函数调用栈帧的展开。CPU当前的状态保存在了Context记录中，并且展开标记在异常记录结构体中有设置。</span><br><span class="line">    如果TargetFrame参数没有指定，那么退出展开标记会设置到异常记录的异常标记中。向后扫描函数调用栈帧，逐一查找</span><br><span class="line">    展开操作代码。</span><br><span class="line">    每遇到一个栈帧，离开当前函数的控制PC就是确定的，并且用于在链接器构建的运行时函数表中查找异常处理信息。</span><br><span class="line">    如果函数有异常处理器，那么就调用它的处理函数。</span><br><span class="line">Arguments:</span><br><span class="line">    TargetFrame - Supplies an optional pointer to the call frame that is the</span><br><span class="line">        target of the unwind. If this parameter is not specified, then an exit</span><br><span class="line">        unwind is performed.	该参数不指定，则退出展开过程</span><br><span class="line">    TargetIp - Supplies an optional instruction address that specifies the</span><br><span class="line">        continuation address of the unwind. This address is ignored if the</span><br><span class="line">        target frame parameter is not specified. 指定了继续执行执行的地址</span><br><span class="line">    ExceptionRecord - Supplies an optional pointer to an exception record.</span><br><span class="line">		异常信息记录</span><br><span class="line">    ReturnValue - Supplies a value that is to be placed in the integer</span><br><span class="line">        function return register just before continuing execution.</span><br><span class="line">    OriginalContext - Supplies a pointer to a context record that can be used</span><br><span class="line">        to store context during the unwind operation.</span><br><span class="line">    HistoryTable - Supplies an optional pointer to an unwind history table.</span><br><span class="line">Return Value:</span><br><span class="line">    None.</span><br><span class="line">--*/</span><br><span class="line">VOID RtlUnwindEx (</span><br><span class="line">    IN PVOID TargetFrame OPTIONAL,</span><br><span class="line">    IN PVOID TargetIp OPTIONAL,</span><br><span class="line">    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,</span><br><span class="line">    IN PVOID ReturnValue,</span><br><span class="line">    IN PCONTEXT OriginalContext,</span><br><span class="line">    IN PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ULONG64 ControlPc;</span><br><span class="line">    PCONTEXT CurrentContext;</span><br><span class="line">    DISPATCHER_CONTEXT DispatcherContext;</span><br><span class="line">    EXCEPTION_DISPOSITION Disposition;</span><br><span class="line">    ULONG64 EstablisherFrame;</span><br><span class="line">    ULONG ExceptionFlags;</span><br><span class="line">    EXCEPTION_RECORD ExceptionRecord1;</span><br><span class="line">    PEXCEPTION_ROUTINE ExceptionRoutine;</span><br><span class="line">    PRUNTIME_FUNCTION FunctionEntry;</span><br><span class="line">    PVOID HandlerData;</span><br><span class="line">    ULONG64 HighLimit;</span><br><span class="line">    ULONG64 ImageBase;</span><br><span class="line">    CONTEXT LocalContext;</span><br><span class="line">    ULONG64 LowLimit;</span><br><span class="line">    PCONTEXT PreviousContext;</span><br><span class="line">    ULONG ScopeIndex;</span><br><span class="line">    PCONTEXT TempContext;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Get current stack limits, capture the current context, virtually</span><br><span class="line">    // unwind to the caller of this routine, get the initial PC value, and</span><br><span class="line">    // set the unwind target address.</span><br><span class="line">    // 获取当前的栈限制，当前的上下文，展开的目标地址等</span><br><span class="line">    CurrentContext = OriginalContext;</span><br><span class="line">    PreviousContext = &amp;LocalContext;</span><br><span class="line">    RtlpGetStackLimits(&amp;LowLimit, &amp;HighLimit);</span><br><span class="line">    RtlCaptureContext(CurrentContext);</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // If a history table is specified, then set to search history table.</span><br><span class="line">    // 如果传入了历史表，那么就设置从历史表中搜索</span><br><span class="line">    if (ARGUMENT_PRESENT(HistoryTable)) &#123;</span><br><span class="line">        HistoryTable-&gt;Search = UNWIND_HISTORY_TABLE_GLOBAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // If an exception record is not specified, then build a local exception</span><br><span class="line">    // record for use in calling exception handlers during the unwind operation.</span><br><span class="line">    // 没有指定异常记录，则构建一个本地的用于在展开操作中调用异常处理函数</span><br><span class="line">    if (ARGUMENT_PRESENT(ExceptionRecord) == FALSE) &#123;</span><br><span class="line">        ExceptionRecord = &amp;ExceptionRecord1;</span><br><span class="line">        ExceptionRecord1.ExceptionCode = STATUS_UNWIND;</span><br><span class="line">        ExceptionRecord1.ExceptionRecord = NULL;</span><br><span class="line">        ExceptionRecord1.ExceptionAddress = (PVOID)CurrentContext-&gt;Rip;</span><br><span class="line">        ExceptionRecord1.NumberParameters = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // If the target frame of the unwind is specified, then a normal unwind</span><br><span class="line">    // is being performed. Otherwise, an exit unwind is being performed.</span><br><span class="line">    // 如果指定了展开的目标栈帧，那么执行正常的展开操作。否则就是执行退出展开。</span><br><span class="line">    ExceptionFlags = EXCEPTION_UNWINDING;</span><br><span class="line">    if (ARGUMENT_PRESENT(TargetFrame) == FALSE) &#123;</span><br><span class="line">        ExceptionFlags |= EXCEPTION_EXIT_UNWIND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // Scan backward through the call frame hierarchy and call exception</span><br><span class="line">    // handlers until the target frame of the unwind is reached.</span><br><span class="line">    // 向后扫描调用帧层，调用异常处理函数，直到到达展开的目标栈帧。</span><br><span class="line">    do &#123;</span><br><span class="line"></span><br><span class="line">        //</span><br><span class="line">        // Lookup the function table entry using the point at which control</span><br><span class="line">        // left the procedure.</span><br><span class="line">        // 查询函数表，找到对应的表象</span><br><span class="line">        ControlPc = CurrentContext-&gt;Rip;</span><br><span class="line">        FunctionEntry = RtlLookupFunctionEntry(ControlPc,</span><br><span class="line">                                               &amp;ImageBase,</span><br><span class="line">                                               HistoryTable);</span><br><span class="line">        //</span><br><span class="line">        // If there is a function table entry for the routine, then virtually</span><br><span class="line">        // unwind to the caller of the routine to obtain the virtual frame</span><br><span class="line">        // pointer of the establisher, but don&apos;t update the context record.</span><br><span class="line">        // 如果找到了函数表条目，然后虚拟展开，获取虚拟栈帧指针，但是不更新上下文记录</span><br><span class="line">        if (FunctionEntry != NULL) &#123;</span><br><span class="line">            RtlpCopyContext(PreviousContext, CurrentContext);</span><br><span class="line">            ExceptionRoutine = RtlVirtualUnwind(UNW_FLAG_UHANDLER,</span><br><span class="line">                                                ImageBase,</span><br><span class="line">                                                ControlPc,</span><br><span class="line">                                                FunctionEntry,</span><br><span class="line">                                                PreviousContext,</span><br><span class="line">                                                &amp;HandlerData,</span><br><span class="line">                                                &amp;EstablisherFrame,</span><br><span class="line">                                                NULL);</span><br><span class="line"></span><br><span class="line">            //</span><br><span class="line">            // If the establisher frame pointer is not within the specified</span><br><span class="line">            // stack limits, the establisher frame pointer is unaligned, or</span><br><span class="line">            // the target frame is below the establisher frame and an exit</span><br><span class="line">            // unwind is not being performed, then raise a bad stack status.</span><br><span class="line">            // Otherwise, check to determine if the current routine has an</span><br><span class="line">            // exception handler.</span><br><span class="line">            // 如果建立者栈帧不在指定的栈界限内容，或者栈帧没有对齐，或者目标栈帧比建立者栈帧小</span><br><span class="line">            // 那么就是出错了，抛出坏栈错误。</span><br><span class="line">            if ((RtlpIsFrameInBounds(&amp;LowLimit, EstablisherFrame, &amp;HighLimit) == FALSE) ||</span><br><span class="line">                 ((ARGUMENT_PRESENT(TargetFrame) != FALSE) &amp;&amp;</span><br><span class="line">                  ((ULONG64)TargetFrame &lt; EstablisherFrame))) &#123;</span><br><span class="line"></span><br><span class="line">                RtlRaiseStatus(STATUS_BAD_STACK);</span><br><span class="line"></span><br><span class="line">            &#125; else if (ExceptionRoutine != NULL) &#123;</span><br><span class="line"></span><br><span class="line">                //</span><br><span class="line">                // The frame has a exception handler.</span><br><span class="line">                //</span><br><span class="line">                // A linkage routine written in assembler is used to actually</span><br><span class="line">                // call the actual exception handler. This is required by the</span><br><span class="line">                // exception handler that is associated with the linkage</span><br><span class="line">                // routine so it can have access to two sets of dispatcher</span><br><span class="line">                // context when it is called.</span><br><span class="line">                //</span><br><span class="line">                // Call the language specific handler.</span><br><span class="line">                // 如果栈帧对应异常处理函数，则调用语言特定处理函数 __C_Specific_handler</span><br><span class="line">                DispatcherContext.TargetIp = (ULONG64)TargetIp;	// 赋值TargetIp，注意在异常分发中没有赋值</span><br><span class="line">                ScopeIndex = 0;</span><br><span class="line">                do &#123;</span><br><span class="line"></span><br><span class="line">                    //</span><br><span class="line">                    // If the establisher frame is the target of the unwind</span><br><span class="line">                    // operation, then set the target unwind flag.</span><br><span class="line">                    // 如果当前栈帧就是展开的目标栈帧，则设置  EXCEPTION_TARGET_UNWIND 标记</span><br><span class="line">                    if ((ULONG64)TargetFrame == EstablisherFrame) &#123;</span><br><span class="line">                        ExceptionFlags |= EXCEPTION_TARGET_UNWIND;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ExceptionRecord-&gt;ExceptionFlags = ExceptionFlags;</span><br><span class="line"></span><br><span class="line">                    //</span><br><span class="line">                    // Set the specified return value and target IP in case</span><br><span class="line">                    // the exception handler directly continues execution.</span><br><span class="line">                    // 设置指定的返回值和目标IP，防止异常处理函数直接继续执行，不返回</span><br><span class="line">                    CurrentContext-&gt;Rax = (ULONG64)ReturnValue;</span><br><span class="line"></span><br><span class="line">                    //</span><br><span class="line">                    // Set the dispatcher context and call the termination</span><br><span class="line">                    // handler.</span><br><span class="line">                    // 设置分发上下文，并且调用处理函数</span><br><span class="line">                    DispatcherContext.ControlPc = ControlPc;</span><br><span class="line">                    DispatcherContext.ImageBase = ImageBase;</span><br><span class="line">                    DispatcherContext.FunctionEntry = FunctionEntry;</span><br><span class="line">                    DispatcherContext.EstablisherFrame = EstablisherFrame;</span><br><span class="line">                    DispatcherContext.ContextRecord = CurrentContext;</span><br><span class="line">                    DispatcherContext.LanguageHandler = ExceptionRoutine;</span><br><span class="line">                    DispatcherContext.HandlerData = HandlerData;</span><br><span class="line">                    DispatcherContext.HistoryTable = HistoryTable;</span><br><span class="line">                    DispatcherContext.ScopeIndex = ScopeIndex;</span><br><span class="line">                    Disposition =</span><br><span class="line">                        RtlpExecuteHandlerForUnwind(ExceptionRecord,</span><br><span class="line">                                                    EstablisherFrame,</span><br><span class="line">                                                    CurrentContext,</span><br><span class="line">                                                    &amp;DispatcherContext);</span><br><span class="line"></span><br><span class="line">                    //</span><br><span class="line">                    // Clear target unwind and collided unwind flags.</span><br><span class="line">                    // 清除标记</span><br><span class="line">                    ExceptionFlags &amp;=</span><br><span class="line">                        ~(EXCEPTION_COLLIDED_UNWIND | EXCEPTION_TARGET_UNWIND);</span><br><span class="line"></span><br><span class="line">                    //</span><br><span class="line">                    // Case on the handler disposition.</span><br><span class="line">                    // 调用结果</span><br><span class="line">                    switch (Disposition) &#123;</span><br><span class="line">                        //</span><br><span class="line">                        // The disposition is to continue the search.</span><br><span class="line">                        //</span><br><span class="line">                        // If the target frame has not been reached, then</span><br><span class="line">                        // swap context pointers.</span><br><span class="line">                        // 继续执行，交换上下文指针</span><br><span class="line">                    case ExceptionContinueSearch :</span><br><span class="line">                        if (EstablisherFrame != (ULONG64)TargetFrame) &#123;</span><br><span class="line">                            TempContext = CurrentContext;</span><br><span class="line">                            CurrentContext = PreviousContext;</span><br><span class="line">                            PreviousContext = TempContext;</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line"></span><br><span class="line">                        //</span><br><span class="line">                        // The disposition is collided unwind.</span><br><span class="line">                        //</span><br><span class="line">                        // Copy the context of the previous unwind and</span><br><span class="line">                        // virtually unwind to the caller of the establisher,</span><br><span class="line">                        // then set the target of the current unwind to the</span><br><span class="line">                        // dispatcher context of the previous unwind, and</span><br><span class="line">                        // reexecute the exception handler from the collided</span><br><span class="line">                        // frame with the collided unwind flag set in the</span><br><span class="line">                        // exception record.</span><br><span class="line">                        // 展开冲突</span><br><span class="line">                    case ExceptionCollidedUnwind :</span><br><span class="line">                        ControlPc = DispatcherContext.ControlPc;</span><br><span class="line">                        ImageBase = DispatcherContext.ImageBase;</span><br><span class="line">                        FunctionEntry = DispatcherContext.FunctionEntry;</span><br><span class="line">                        RtlpCopyContext(OriginalContext,</span><br><span class="line">                                        DispatcherContext.ContextRecord);</span><br><span class="line"></span><br><span class="line">                        CurrentContext = OriginalContext;</span><br><span class="line">                        PreviousContext = &amp;LocalContext;</span><br><span class="line">                        RtlpCopyContext(PreviousContext, CurrentContext);</span><br><span class="line">                        RtlVirtualUnwind(UNW_FLAG_NHANDLER,</span><br><span class="line">                                         ImageBase,</span><br><span class="line">                                         ControlPc,</span><br><span class="line">                                         FunctionEntry,</span><br><span class="line">                                         PreviousContext,</span><br><span class="line">                                         &amp;HandlerData,</span><br><span class="line">                                         &amp;EstablisherFrame,</span><br><span class="line">                                         NULL);</span><br><span class="line"></span><br><span class="line">                        EstablisherFrame = DispatcherContext.EstablisherFrame;</span><br><span class="line">                        ExceptionRoutine = DispatcherContext.LanguageHandler;</span><br><span class="line">                        HandlerData = DispatcherContext.HandlerData;</span><br><span class="line">                        HistoryTable = DispatcherContext.HistoryTable;</span><br><span class="line">                        ScopeIndex = DispatcherContext.ScopeIndex;</span><br><span class="line">                        ExceptionFlags |= EXCEPTION_COLLIDED_UNWIND;</span><br><span class="line">                        break;</span><br><span class="line"></span><br><span class="line">                        //</span><br><span class="line">                        // All other disposition values are invalid.</span><br><span class="line">                        //</span><br><span class="line">                        // Raise invalid disposition exception.</span><br><span class="line">                        //</span><br><span class="line">                    default :</span><br><span class="line">                        RtlRaiseStatus(STATUS_INVALID_DISPOSITION);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; while ((ExceptionFlags &amp; EXCEPTION_COLLIDED_UNWIND) != 0);</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //</span><br><span class="line">                // If the target frame has not been reached, then swap</span><br><span class="line">                // context pointers.</span><br><span class="line">                // 没有到达目标栈帧，则交换上下文记录指针，继续搜索</span><br><span class="line">                if (EstablisherFrame != (ULONG64)TargetFrame) &#123;</span><br><span class="line">                    TempContext = CurrentContext;</span><br><span class="line">                    CurrentContext = PreviousContext;</span><br><span class="line">                    PreviousContext = TempContext;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            //</span><br><span class="line">            // Set the point where control left the current function by</span><br><span class="line">            // obtaining the return address from the top of the stack.</span><br><span class="line">            // 控制离开当前函数，获取返回值，继续遍历之前的函数。</span><br><span class="line">            CurrentContext-&gt;Rip = *(PULONG64)(CurrentContext-&gt;Rsp);</span><br><span class="line">            CurrentContext-&gt;Rsp += 8;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((RtlpIsFrameInBounds(&amp;LowLimit, EstablisherFrame, &amp;HighLimit) == TRUE) &amp;&amp;</span><br><span class="line">             (EstablisherFrame != (ULONG64)TargetFrame));</span><br><span class="line"></span><br><span class="line">    //</span><br><span class="line">    // If the establisher stack pointer is equal to the target frame pointer,</span><br><span class="line">    // then continue execution. Otherwise, an exit unwind was performed or the</span><br><span class="line">    // target of the unwind did not exist and the debugger and subsystem are</span><br><span class="line">    // given a second chance to handle the unwind.</span><br><span class="line">    // 建立者栈帧 和目标栈帧相同，那么继续执行。否则执行展开退出，如果展开目标不存在，调试器和子系统</span><br><span class="line">    // 会第二次处理展开</span><br><span class="line">    if (EstablisherFrame == (ULONG64)TargetFrame) &#123;</span><br><span class="line">        CurrentContext-&gt;Rax = (ULONG64)ReturnValue;</span><br><span class="line">        if (ExceptionRecord-&gt;ExceptionCode != STATUS_UNWIND_CONSOLIDATE) &#123;</span><br><span class="line">            CurrentContext-&gt;Rip = (ULONG64)TargetIp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RtlRestoreContext(CurrentContext, ExceptionRecord);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 对错误情况进行处理</span><br><span class="line">        // If the old control PC is the same as the new control PC, then</span><br><span class="line">        // no progress is being made and the function tables are most likely</span><br><span class="line">        // malformed. Otherwise, give the debugger and subsystem a second</span><br><span class="line">        // chance to handle the exception.</span><br><span class="line">        if (ControlPc == CurrentContext-&gt;Rip) &#123;</span><br><span class="line">            RtlRaiseStatus(STATUS_BAD_FUNCTION_TABLE);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ZwRaiseException(ExceptionRecord, CurrentContext, FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过注释对RtlUnwindEx()函数也就有了比较充分的了解，这里不再重复这个过程了。将整个异常处理的过程简单叙述一下，以帮助整体理解。</p>
<p>异常发生后，首先CPU会在内核内进行一些处理（这块见之前一些文章总结与分析），对于Ring3层的异常最终会调回到Ring3层的RtlDispatchException()函数（该函数内核和Ring3的逻辑是相同的），RtlDispatchException会根据ControlPC（即异常发生点的代码地址）查找运行时函数表（<code>RUNTIME_FUNCTIONS</code>）来查找目标表项。在找到目标表项后，调用RtlVirtualUnwind()函数进行虚拟展开，一方面找到当前函数的异常处理函数（<code>_C_specific_handler</code>）以调用它来过滤异常；另一方面，虚拟展开中会将当前栈帧展开，相关的内容填写到复制的一份上下文中，用于调用异常处理函数使用；再就是在虚拟展开中会获取到当前异常信息中的ScopeTable等数据。调用<code>_C_specific_handler</code>函数对ScopeTable遍历，进行异常过滤函数调用（可能是一个代码块，或简单地就是一个<code>EXCEPTION_EXECUTE_HANDLER</code>值）。如果异常过滤函数返回0，则继续遍历；如果异常过滤函数返回-1，则返回到异常发生位置继续执行；如果异常过滤函数返回1（处理异常），则进行异常展开，调用RtlUnwindEx()。异常展开函数类似异常分发过程，进行虚拟展开并在此调用异常处理函数<code>_C_specific_handler</code>（但是不同于异常分发，带有展开标记）。对于有finally语句的try块，则直接调用该代码块，否则继续进行展开；展开栈帧到了目标栈帧，则返回到<code>_C_specific_handler</code>函数，由于上下文已经被恢复到TargetIP（即异常处理的except代码块），<code>_C_specific_handler</code>函数直接return去继续执行接下来的代码。</p>
<p>这里将正常的异常处理过程过了一遍，还有许多内容没有详细分析总结，奈何能力不足，心有余力不足，待到以后资料阅读够多，再详细补充。</p>
<p><strong>未总结内容</strong></p>
<ol>
<li>“ExceptionNestedException 和 ExceptionCollidedUnwind”</li>
</ol>
<p><strong>参考文章</strong></p>
<ul>
<li>SEH分析笔记（X86篇）   <a href="http://boxcounter.com/technique/2011-11-04-seh-x64/" target="_blank" rel="noopener">http://boxcounter.com/technique/2011-11-04-seh-x64/</a></li>
<li>Exceptional Behavior – x64 Structured Exception Handling        <a href="http://www.osronline.com/article.cfm?article=469" target="_blank" rel="noopener">http://www.osronline.com/article.cfm?article=469</a></li>
<li>配置64位的程序（Visual C++） <a href="https://msdn.microsoft.com/zh-cn/library/h2k70f3s.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/h2k70f3s.aspx</a></li>
<li>异常处理 (x64) <a href="https://msdn.microsoft.com/zh-cn/library/1eyas8tf.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/1eyas8tf.aspx</a></li>
<li>Programming against the x64 exception handling support<a href="http://www.nynaeve.net/?p=113" target="_blank" rel="noopener">http://www.nynaeve.net/?p=113</a></li>
<li>SEH X64 <a href="http://m.blog.csdn.net/qq_18218335/article/details/72722320" target="_blank" rel="noopener">http://m.blog.csdn.net/qq_18218335/article/details/72722320</a></li>
</ul>
<p><strong>修订历史</strong></p>
<ul>
<li>2017-08-16 11:21:23        完成文章</li>
</ul>
<p>By Andy @2017-08-16 20:13:23</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/调试/">调试</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Windbg/">Windbg</a><a href="/tags/Exception/">Exception</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://dbgtech.github.io/2017/08/04/Windows-X64-Try-Except-Finally.html" data-title="Windows X64的Ring3层异常处理机制 | DbgTech" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/09/03/Bochs-Internal-debugger-manual-translation.html" title="Bochs内置调试器使用">
  <strong>上一篇：</strong><br/>
  <span>
  Bochs内置调试器使用</span>
</a>
</div>


<div class="next">
<a href="/2017/07/26/VS2008-Windows-Try-Except-Finally.html"  title="Windows X86的ring3结构化异常处理">
 <strong>下一篇：</strong><br/> 
 <span>Windows X86的ring3结构化异常处理
</span>
</a>
</div>

</nav>

	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常信息注册"><span class="toc-number">1.</span> <span class="toc-text">异常信息注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常分发"><span class="toc-number">2.</span> <span class="toc-text">异常分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理和堆栈展开"><span class="toc-number">3.</span> <span class="toc-text">异常处理和堆栈展开</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  <div class="linkslist">
  <p class="asidetitle">专栏</p>
    <ul>
        
          <li>
            
            	<a href="https://dbgtech.github.io/Tools/" target="_blank" title="常用工具">常用工具</a>
            
          </li>
        
    </ul>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/散记/" title="散记">散记<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/笔记/" title="笔记">笔记<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/翻译/笔记/" title="笔记">笔记<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/翻译/" title="翻译">翻译<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/读书/" title="读书">读书<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/调试/" title="调试">调试<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/转载/" title="转载">转载<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Windbg/" title="Windbg">Windbg<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Exception/" title="Exception">Exception<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Windows/" title="Windows">Windows<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/心情/" title="心情">心情<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/X86汇编/" title="X86汇编">X86汇编<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Markdown/" title="Markdown">Markdown<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/笔记/" title="笔记">笔记<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Stack-Cookie/" title="Stack Cookie">Stack Cookie<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/time/" title="time">time<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C-C/" title="C/C++">C/C++<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Win10/" title="Win10">Win10<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UWP/" title="UWP">UWP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/读书笔记/" title="读书笔记">读书笔记<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C-C/" title="C\C++">C\C++<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/反思/" title="反思">反思<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/翻译/" title="翻译">翻译<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/实模式/" title="实模式">实模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/保护模式/" title="保护模式">保护模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/运行时库/" title="运行时库">运行时库<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/WSL/" title="WSL">WSL<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://git-scm.com/book/zh/v2" target="_blank" title="Git">Git</a>
            
          </li>
        
          <li>
            
            	<a href="https://hexo.io/zh-cn/docs/" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="http://36kr.com/" target="_blank" title="36氪">36氪</a>
            
          </li>
        
          <li>
            
            	<a href="https://wiki.osdev.org/Expanded_Main_Page" target="_blank" title="OSDev">OSDev</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.reactos.com/" target="_blank" title="ReactOS">ReactOS</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.freebuf.com/" target="_blank" title="FreeBuf">FreeBuf</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.appinn.com/markdown/" target="_blank" title="Makedown">Makedown</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.huxiu.com/" target="_blank" title="虎嗅网">虎嗅网</a>
            
          </li>
        
          <li>
            
            	<a href="http://bbs.pediy.com/" target="_blank" title="看雪论坛">看雪论坛</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.geekpark.net/" target="_blank" title="极客公园">极客公园</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">归档</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li></ul>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="Andy Guo">Andy Guo</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>

