
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>  
  <meta charset="UTF-8">
  
    <title>C\C++运行时库源代码阅读 | DbgTech</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Andy Guo">
    

    
    <meta name="description" content="C\C++运行时库主要是提供了C\C++运行时使用的一些公用函数，包括参数处理，浮点运算，内存处理，输入输出，国际化，内存的分配与释放管理，数据类型转换，调试，目录控制等等。 这些函数可以静态链接或动态链接库的形式提供给C\C++程序使用。静态链接，就是将代码嵌入到EXE或DLL中，编译出来的文件比较大。但是它不需要再依赖动态运行时库，如MSVCR80.dll等；动态链接库，仅仅将库的导出函数信息">
<meta name="keywords" content="C\C++,运行时库">
<meta property="og:type" content="article">
<meta property="og:title" content="C\C++运行时库源代码阅读">
<meta property="og:url" content="https://dbgtech.github.io/2017/05/17/C-runtime-library-analysis.html">
<meta property="og:site_name" content="DbgTech">
<meta property="og:description" content="C\C++运行时库主要是提供了C\C++运行时使用的一些公用函数，包括参数处理，浮点运算，内存处理，输入输出，国际化，内存的分配与释放管理，数据类型转换，调试，目录控制等等。 这些函数可以静态链接或动态链接库的形式提供给C\C++程序使用。静态链接，就是将代码嵌入到EXE或DLL中，编译出来的文件比较大。但是它不需要再依赖动态运行时库，如MSVCR80.dll等；动态链接库，仅仅将库的导出函数信息">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-06-06T12:16:06.523Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C\C++运行时库源代码阅读">
<meta name="twitter:description" content="C\C++运行时库主要是提供了C\C++运行时使用的一些公用函数，包括参数处理，浮点运算，内存处理，输入输出，国际化，内存的分配与释放管理，数据类型转换，调试，目录控制等等。 这些函数可以静态链接或动态链接库的形式提供给C\C++程序使用。静态链接，就是将代码嵌入到EXE或DLL中，编译出来的文件比较大。但是它不需要再依赖动态运行时库，如MSVCR80.dll等；动态链接库，仅仅将库的导出函数信息">

    
    <link rel="alternative" href="/atom.xml" title="DbgTech" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="DbgTech" title="DbgTech"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="DbgTech">DbgTech</a></h1>
				<h2 class="blog-motto">—— 慢下来，享受思考的小确幸！</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/column">Column</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/17/C-runtime-library-analysis.html" title="C\C++运行时库源代码阅读" itemprop="url">C\C++运行时库源代码阅读</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Andy Guo" target="_blank" itemprop="author">Andy Guo</a>
		
  <p class="article-time">
    <time datetime="2017-05-17T03:33:32.000Z" itemprop="datePublished"> 发表于 2017-05-17</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#动态链接会使用-crtexe-c中的内容"><span class="toc-number">1.</span> <span class="toc-text">动态链接会使用 crtexe.c中的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态链接会使用-crt0-c中的内容"><span class="toc-number">2.</span> <span class="toc-text">静态链接会使用 crt0.c中的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Win32程序与Console程序的一个不同点"><span class="toc-number">3.</span> <span class="toc-text">Win32程序与Console程序的一个不同点</span></a></li></ol>
		
		</div>
		
		<p><code>C\C++</code>运行时库主要是提供了<code>C\C++</code>运行时使用的一些公用函数，包括参数处理，浮点运算，内存处理，输入输出，国际化，内存的分配与释放管理，数据类型转换，调试，目录控制等等。</p>
<p>这些函数可以静态链接或动态链接库的形式提供给<code>C\C++</code>程序使用。静态链接，就是将代码嵌入到EXE或DLL中，编译出来的文件比较大。但是它不需要再依赖动态运行时库，如MSVCR80.dll等；动态链接库，仅仅将库的导出函数信息编译到EXE中，在程序运行时，需要动态加载MSVCR80.dll等运行时库文件。</p>
<p>由于运行时库中包含了众多公用函数，这些公用函数，比如new，需要调用系统的一些函数进行初始化，所以运行时库也是需要初始化的。至于初始化时机，不用说肯定要在用户代码运行之前。否则程序代码调用了new方法，而此时还没有准备好可以分配的内存。那就出现错误了。对于Win32控制台程序，就是要在main()函数执行之前。</p>
<p>VC的做法是在编译器提供模块的入口函数，在模块的入口函数中，先调用CRT的初始化逻辑，然后在调用main()函数。即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CRT入口函数()</span><br><span class="line">&#123;</span><br><span class="line">    CRT初始化</span><br><span class="line">    main()</span><br><span class="line">    CRT清理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以VS2008为例，简单过一下 CRT的初始化与清理：<br><a id="more"></a></p>
<h4 id="动态链接会使用-crtexe-c中的内容"><a href="#动态链接会使用-crtexe-c中的内容" class="headerlink" title="动态链接会使用 crtexe.c中的内容"></a>动态链接会使用 crtexe.c中的内容</h4><p>文件目录为*\Microsoft Visual Studio 9.0\VC\crt\src\crtexe.c</p>
<blockquote>
<p>* 表示VS2008的安装目录。</p>
</blockquote>
<p>对于EXE，根据不同程序类型（<code>UNICODE/ASCII</code>，控制台和Win32程序），入口函数不同。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _WINMAIN_        // Win32程序</span><br><span class="line"></span><br><span class="line">#ifdef WPRFLAG          // UNICODE程序</span><br><span class="line">int wWinMainCRTStartup(</span><br><span class="line">#else  /* WPRFLAG */</span><br><span class="line">int WinMainCRTStartup(</span><br><span class="line">#endif  /* WPRFLAG */</span><br><span class="line"></span><br><span class="line">#else  /* _WINMAIN_ */  // 控制台程序</span><br><span class="line"></span><br><span class="line">#ifdef WPRFLAG          // UNICODE程序</span><br><span class="line">int wmainCRTStartup(</span><br><span class="line">#else  /* WPRFLAG */</span><br><span class="line">int mainCRTStartup(</span><br><span class="line">#endif  /* WPRFLAG */</span><br><span class="line"></span><br><span class="line">#endif  /* _WINMAIN_ */</span><br><span class="line">        void</span><br><span class="line">        )</span><br><span class="line">&#123;</span><br><span class="line">        /*</span><br><span class="line">         * The /GS security cookie must be initialized before any exception</span><br><span class="line">         * handling targetting the current image is registered.  No function</span><br><span class="line">         * using exception handling can be called in the current image until</span><br><span class="line">         * after __security_init_cookie has been called.</span><br><span class="line">         */</span><br><span class="line">        __security_init_cookie();</span><br><span class="line"></span><br><span class="line">        return __tmainCRTStartup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的例子CRunTime使用VC2008默认的编译，及UNICODE形式的控制台程序，那么它的起始函数为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_wmainCRTStartup()</span><br></pre></td></tr></table></figure>
<p><strong>1. GS机制初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The /GS security cookie must be initialized before any exception</span><br><span class="line"> * handling targetting the current image is registered.  No function</span><br><span class="line"> * using exception handling can be called in the current image until</span><br><span class="line"> * after __security_init_cookie has been called.</span><br><span class="line"> */</span><br><span class="line">__security_init_cookie();</span><br></pre></td></tr></table></figure>
<p>GS安全cookie必须在任何基于当前映像的异常处理被注册之前初始化。直到该函数被调用，任何使用异常处理的函数都不能调用。</p>
<p>对于32位的GS机制，需要定义一个全局的安全cookie变量，它保存了计算出来的cookie值，用于校验cookie时使用。这个全局变量需要有一个初始值，防止在安全cookie初始化函数调用之前有用到cookie的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define DEFAULT_SECURITY_COOKIE 0xBB40E64E</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The global security cookie.  This name is known to the compiler.</span><br><span class="line"> * Initialize to a garbage non-zero value just in case we have a buffer overrun</span><br><span class="line"> * in any code that gets run before __security_init_cookie() has a chance to</span><br><span class="line"> * initialize the cookie to the final value.</span><br><span class="line"> */</span><br><span class="line">DECLSPEC_SELECTANY UINT_PTR __security_cookie = DEFAULT_SECURITY_COOKIE;</span><br></pre></td></tr></table></figure>
<p><strong>cookie值的生成：</strong><br>&emsp;&emsp;1.取时间值的低32位<br>&emsp;&emsp;2.异或上时间值的高32位<br>&emsp;&emsp;3.异或当前线程ID<br>&emsp;&emsp;4.异或当前进程ID<br>&emsp;&emsp;5.异或启动机器的毫秒数<br>&emsp;&emsp;6.异或性能计数值的高32位 和低32位<br>&emsp;&emsp;7.如果结果值和默认的cookie相同，则将值加1<br>&emsp;&emsp;8.如果cookie高两字节为0，则将低两字节复制到高两字节</p>
<p>上述的这些内容，无非是为了让cookie在当前的进程中尽量随机且唯一。</p>
<p><strong>2. 如下的函数都是在<strong>try/</strong>except防护中完成的。作为应用程序的一个起始异常处理</strong></p>
<p>首先判断当前代码是否在被调用。</p>
<p>判断 __native_startup_lock 是否为空，如果为空，则将当前栈基址赋值给它。如果有线程在执行本段初始化代码，且线程不是当前线程，则等待。</p>
<p>线程可重入，如果是当前线程，则直接进入。</p>
<p>如果正在初始化，则退出如果还没有初始化，则设置全局状态变量为 <strong>initializing，并且调用 _initterm((_PVFV <em>)(void </em>)</strong>xi_a, (_PVFV <em>)(void </em>)__xi_z);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_initterm(__xc_a, __xc_z)   // 做C++构造函数调用</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 如果有任何的动态初始化的<code>__declspec(thread)</code>的变量，则调用初始化函数。通过定义在<code>tlsdyn.obj</code>中的一个回调函数</strong></p>
<p><code>__dyn_tls_init()</code>，来初始化这些变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (__dyn_tls_init_callback != NULL &amp;&amp;</span><br><span class="line">    _IsNonwritableInCurrentImage((PBYTE)&amp;__dyn_tls_init_callback))</span><br><span class="line">&#123;</span><br><span class="line">    __dyn_tls_init_callback(NULL, DLL_THREAD_ATTACH, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会通过<code>func(__xd_a, __xd_z)</code>来进行初始化。</p>
<p><strong>4. 获取命令行</strong></p>
<p>主要是找出 exe之后的命令行内容，方便下面调用 wmain()等函数</p>
<p><strong>5. 然后就直接调用 wmain()方法</strong></p>
<p>mainret = main(argc, argv, envp);</p>
<h4 id="静态链接会使用-crt0-c中的内容"><a href="#静态链接会使用-crt0-c中的内容" class="headerlink" title="静态链接会使用 crt0.c中的内容"></a>静态链接会使用 crt0.c中的内容</h4><p>首先，被作为模块入口，并且做CRT初始化和清理的函数位于crt0.c中，路径如下：<br><code>*\Microsoft Visual Studio 9.0\VC\crt\src\crt0.c</code></p>
<blockquote>
<p>* 表示VS2008的安装目录。</p>
</blockquote>
<p>我们的例子CRunTime使用VC2008默认的编译，及UNICODE形式的控制台程序，那么它的起始函数为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_tmainCRTStartup()</span><br></pre></td></tr></table></figure>
<p>如下为该文件的起始处的说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">*mainCRTStartup(void)</span><br><span class="line">*wmainCRTStartup(void)</span><br><span class="line">*WinMainCRTStartup(void)</span><br><span class="line">*wWinMainCRTStartup(void)</span><br><span class="line">*</span><br><span class="line">*Purpose:</span><br><span class="line">*       These routines do the C runtime initialization, call the appropriate</span><br><span class="line">*       user entry function, and handle termination cleanup.  For a managed</span><br><span class="line">*       app, they then return the exit code back to the calling routine, which</span><br><span class="line">*       is the managed startup code.  For an unmanaged app, they call exit and</span><br><span class="line">*       never return.</span><br><span class="line">*</span><br><span class="line">*       Function:               User entry called:</span><br><span class="line">*       mainCRTStartup          main</span><br><span class="line">*       wmainCRTStartup         wmain</span><br><span class="line">*       WinMainCRTStartup       WinMain</span><br><span class="line">*       wWinMainCRTStartup      wWinMain</span><br><span class="line">*</span><br><span class="line">*Entry:</span><br><span class="line">*</span><br><span class="line">*Exit:</span><br><span class="line">*       Managed app: return value from main() et al, or the exception code if</span><br><span class="line">*                 execution was terminated by the __except guarding the call</span><br><span class="line">*                 to main().</span><br><span class="line">*       Unmanaged app: never return.</span><br><span class="line">*</span><br><span class="line">*******************************************************************************/</span><br></pre></td></tr></table></figure>
<p>大致意思是：上面这些函数都是做C运行时初始化的，然后调用合适的用户入口函数，并且处理程序结束时的清理工作。对于托管的程序，他们会将推出代码返回给调用历程，这个代码是托管启动代码。对于未托管的程序，则调用exit，并且不会再返回。</p>
<p>首先以Win32控制台程序为例，中间穿插着Win32应用程序与它的不同的地方：</p>
<p><strong>1. GS机制初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The /GS security cookie must be initialized before any exception</span><br><span class="line"> * handling targetting the current image is registered.  No function</span><br><span class="line"> * using exception handling can be called in the current image until</span><br><span class="line"> * after __security_init_cookie has been called.</span><br><span class="line"> */</span><br><span class="line">__security_init_cookie();</span><br></pre></td></tr></table></figure>
<p>GS安全cookie必须在任何基于当前映像的异常处理被注册之前初始化。直到该函数被调用，任何使用异常处理的函数都不能调用。</p>
<p>对于32位的GS机制，需要定义一个全局的安全cookie变量，它保存了计算出来的cookie值，用于校验cookie时使用。这个全局变量需要有一个初始值，防止在安全cookie初始化函数调用之前有用到cookie的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define DEFAULT_SECURITY_COOKIE 0xBB40E64E</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The global security cookie.  This name is known to the compiler.</span><br><span class="line"> * Initialize to a garbage non-zero value just in case we have a buffer overrun</span><br><span class="line"> * in any code that gets run before __security_init_cookie() has a chance to</span><br><span class="line"> * initialize the cookie to the final value.</span><br><span class="line"> */</span><br><span class="line">DECLSPEC_SELECTANY UINT_PTR __security_cookie = DEFAULT_SECURITY_COOKIE;</span><br></pre></td></tr></table></figure>
<p><strong>cookie值的生成:</strong><br>&emsp;&emsp;1.取时间值的低32位<br>&emsp;&emsp;2.异或上时间值的高32位<br>&emsp;&emsp;3.异或当前线程ID<br>&emsp;&emsp;4.异或当前进程ID<br>&emsp;&emsp;5.异或启动机器的毫秒数<br>&emsp;&emsp;6.异或性能计数值的高32位 和低32位<br>&emsp;&emsp;7.如果结果值和默认的cookie相同，则将值加1<br>&emsp;&emsp;8.如果cookie高两字节为0，则将低两字节复制到高两字节</p>
<p>&emsp;&emsp;上述的这些内容，无非是为了让cookie在当前的进程中尽量随机且唯一。</p>
<p><strong>2. 判断是否为托管应用程序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Determine if this is a managed application</span><br><span class="line"> */</span><br><span class="line">managedapp = check_managed_app();</span><br></pre></td></tr></table></figure>
<p>确定应用程序是否是托管程序。PE文件目录表中<code>IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 COM Runtime descriptor</code>存在，且其存在虚地址。</p>
<p><strong>3. <code>_heap_init(1)</code>初始化堆</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">*_heap_init() - Initialize the heap</span><br><span class="line">*</span><br><span class="line">*Purpose:</span><br><span class="line">*       Setup the initial C library heap.</span><br><span class="line">*</span><br><span class="line">*       NOTES:</span><br><span class="line">*       (1) This routine should only be called once!</span><br><span class="line">*       (2) This routine must be called before any other heap requests.</span><br><span class="line">*</span><br><span class="line">*Entry:</span><br><span class="line">*       &lt;void&gt;</span><br><span class="line">*Exit:</span><br><span class="line">*       Returns 1 if successful, 0 otherwise.</span><br><span class="line">*</span><br><span class="line">*Exceptions:</span><br><span class="line">*       If heap cannot be initialized, the program will be terminated</span><br><span class="line">*       with a fatal runtime error.</span><br><span class="line">*</span><br><span class="line">*******************************************************************************/</span><br></pre></td></tr></table></figure>
<p>源码中堆函数的描述：<br>目的是建立初始的C库堆(这个函数应该只被调用一次)。其次，函数应该在其他的堆请求之前调用。如果堆不能初始化，应用程序以严重的运行时错误而被终止。首先创建一个 big-block堆，如果创建失败，则程序直接退出。</p>
<p>对于X86程序，调用<code>__heap_select()</code>函数选择一个堆类型，该函数会返回<code>__V6_HEAP</code>，<code>__V5_HEAP</code>或<code>__SYSTEM_HEAP</code> 三种类型之一。对于使用静态运行时库，只会使用系统堆。对于使用CRT动态库时，通过 GetEnvironmentVariableA 获取环境变量中对堆的配置<code>__HEAP_ENV_STRING</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define __HEAP_ENV_STRING       &quot;__MSVCRT_HEAP_SELECT&quot;</span><br></pre></td></tr></table></figure>
<p>如果该字段对应的值为 __GLOBAL_HEAP_SELECTOR，则为获取到环境堆选择字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define __GLOBAL_HEAP_SELECTOR  &quot;__GLOBAL_HEAP_SELECTED&quot;</span><br></pre></td></tr></table></figure>
<p>否则获取从环境变量串中查找应用程序名称，环境堆选择字符串中查找 ‘,’字符，该字符串后的数字为选择的堆类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define __SYSTEM_HEAP           1</span><br><span class="line">#define __V5_HEAP               2</span><br><span class="line">#define __V6_HEAP               3</span><br></pre></td></tr></table></figure>
<p>对于<code>__V6_HEAP</code>类型的堆,调用<code>__sbh_heap_init()</code>初始化小块堆。该函数中，在<code>_crtheap</code>上创建了一个<code>__sbh_pHeaderList</code>分别初始化了门限值，Header列表大小等值。<br>具体的内容后面研究堆时再详细解释。</p>
<p>对于<code>__V5_HEAP</code>类型的堆（老版本的运行时库堆），通过调用<code>__old_sbh_new_region()</code>函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">*__old_sbh_region_t * __old_sbh_new_region() - get a region for the small-block heap</span><br><span class="line">*</span><br><span class="line">*Purpose:</span><br><span class="line">*       Creates and adds a new region for the small-block heap. First, a</span><br><span class="line">*       descriptor (__old_sbh_region_t) is obtained for the new region. Next,</span><br><span class="line">*       VirtualAlloc() is used to reserved an address space of size</span><br><span class="line">*       _OLD_PAGES_PER_REGION * _OLD_PAGESIZE, and the first _PAGES_PER_COMMITTMENT</span><br><span class="line">*       pages are committed.</span><br><span class="line">*</span><br><span class="line">*       Note that if __old_small_block_heap is available (i.e., the p_pages_begin</span><br><span class="line">*       field is _OLD_NO_PAGES), it becomes the descriptor for the new regions. This is</span><br><span class="line">*       basically the small-block heap initialization.</span><br><span class="line">*</span><br><span class="line">*Entry:</span><br><span class="line">*       No arguments.</span><br><span class="line">*</span><br><span class="line">*Exit:</span><br><span class="line">*       If successful, a pointer to the descriptor for the new region is</span><br><span class="line">*       returned. Otherwise, NULL is returned.</span><br><span class="line">*</span><br><span class="line">*******************************************************************************/</span><br></pre></td></tr></table></figure>
<p>从函数的说明上，它会为小块堆获取一个区。即创建和增加一个区，并且要创建一个描述符，来描述这个区块。这块的内容，也在后面研究堆时，再详述。<code>__V5_HEAP</code>这种老式的堆分配也只会在动态库中才会存在。</p>
<blockquote>
<p>ULONG HeapType = 2;<br>HeapSetInformation(_crtheap, HeapCompatibilityInformation, &amp;HeapType, sizeof(HeapType));<br>对于X64的系统，开启低碎片堆。8字节开销的堆通常比16字节开销的堆有更好的性能。<br>尤其对于需要执行大量小块分配的应用程序。</p>
</blockquote>
<p><strong>4. 初始化的多线程：<code>_mtinit()</code></strong></p>
<p>先看一下函数的说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/****</span><br><span class="line">*_mtinit() - Init multi-thread data bases</span><br><span class="line">*</span><br><span class="line">*Purpose:</span><br><span class="line">*       (1) Call _mtinitlocks to create/open all lock semaphores.</span><br><span class="line">*       (2) Allocate a TLS index to hold pointers to per-thread data</span><br><span class="line">*           structure.</span><br><span class="line">*</span><br><span class="line">*       NOTES:</span><br><span class="line">*       (1) Only to be called ONCE at startup</span><br><span class="line">*       (2) Must be called BEFORE any mthread requests are made</span><br><span class="line">*</span><br><span class="line">*Entry:</span><br><span class="line">*       &lt;NONE&gt;</span><br><span class="line">*Exit:</span><br><span class="line">*       returns FALSE on failure</span><br><span class="line">*</span><br><span class="line">*Uses:</span><br><span class="line">*       &lt;any registers may be modified at init time&gt;</span><br><span class="line">*</span><br><span class="line">*Exceptions:</span><br><span class="line">*</span><br><span class="line">*******************************************************************************/</span><br></pre></td></tr></table></figure>
<p>初始化多线程数据基础。两个目的，一个是调用多线程初始化锁，创建并打开用于锁的信号量。第二个是分配TLS索引值，用于保存每一个线程数据的指针。等待加载Kernel32.dll模块，获取FlsAlloc/FlsGetValue/FlsSetValue/FlsFree。如果失败了，则获取TlsAlloc/TlsGetValue/TlsSetValue/TlsFree等函数。分配用于存储FlsGetValue函数的指针。初始化全局函数指针，分别是如下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">heap_handler()</span><br><span class="line">initcrit()</span><br><span class="line">invarg()</span><br><span class="line">purevirt()</span><br><span class="line">rand_s()</span><br><span class="line">winsig()</span><br><span class="line">winxfltr()</span><br><span class="line">eh_hooks()</span><br><span class="line">aexit_rtn()</span><br></pre></td></tr></table></figure>
<p>初始化多线程锁，<code>_locktable[]</code>组分配条目，标记为lkPrealloc。将lock指向lclcritsects数组的CS结构变量分配一个tls索引，用于维护每一个线程数据的指针。为当前线程创建一个每个线程都有的数据结构。<code>_tiddata</code>同时初始化这个结构体，并将<code>_tid</code>设置为当前线程ID，<code>_thandle</code>设置为 -1。</p>
<p><strong>5. 如果开启了 运行时检查 功能，则要初始化该功能</strong></p>
<p>未找到对应源码，后续补充！</p>
<p><strong>6. <code>_ioinit()</code>进行低级I/O初始化</strong></p>
<p>首先获取启动信息，如果获取失败，就返回。分配一个ioinfo结构体数组，用<code>__pioinfo[0]</code>指向它，并以此进行初始化。如果有继承的句柄，则处理继承的文件句柄信息。这块的信息在<code>StartupInfo.cbReserved2/StartupInfo.lpReserved</code> 两个成员中然后遍历继承的句柄，将继承到的句柄。依次分配<code>ioinfo</code>结构体，填入到<code>__pioinfo[]</code>数组中，从下标1开始。</p>
<p>如果没有继承标准输入，输出，错误文件句柄，则尝试从系统中直接获取。并且将它们设置到适当的osfile域中。对于继承的标准句柄，要保证他们是具有文本模式的。最后，将支持的句柄数量设置到<code>_nhandle</code>变量中</p>
<p><strong>7. 获取命令行和环境变量信息</strong></p>
<p><code>GetCommandLineT()/GetEnvironmentStringT()</code> 这两个函数都是对系统API的封装</p>
<p><code>_tsetargv()/_tsetenvp()</code>   // 代码中无实际作用</p>
<p><strong>8. C 初始化<code>_cinit()</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/***</span><br><span class="line">*_cinit - C initialization</span><br><span class="line">*</span><br><span class="line">*Purpose:</span><br><span class="line">*       This routine performs the shared DOS and Windows initialization.</span><br><span class="line">*       The following order of initialization must be preserved -</span><br><span class="line">*</span><br><span class="line">*       1.  Check for devices for file handles 0 - 2</span><br><span class="line">*       2.  Integer divide interrupt vector setup</span><br><span class="line">*       3.  General C initializer routines</span><br><span class="line">*</span><br><span class="line">*Entry:</span><br><span class="line">*       No parameters: Called from __crtstart and assumes data</span><br><span class="line">*       set up correctly there.</span><br><span class="line">*</span><br><span class="line">*Exit:</span><br><span class="line">*       Initializes C runtime data.</span><br><span class="line">*       Returns 0 if all .CRT$XI internal initializations succeeded, else</span><br><span class="line">*       the _RT_* fatal error code encountered.</span><br><span class="line">*</span><br><span class="line">*Exceptions:</span><br><span class="line">*</span><br><span class="line">*******************************************************************************/</span><br></pre></td></tr></table></figure>
<p>这个函数执行共享的DOS和Windows的初始化。必须按照如下的序列进行初始化。<br>&emsp;&emsp;1.校验文件句柄 0 - 2<br>&emsp;&emsp;2.整数除法中断向量设置<br>&emsp;&emsp;3.通用的C初始化函数调用</p>
<p><code>_FPinit</code>调用，浮点数包初始化。（如果有的话）。</p>
<p><code>_initp_misc_cfltcvt_tab()</code>将数组的指针进行编码，具体作用待查。</p>
<p><code>_initterm_e(__xi_a, __xi_z)</code>执行注册在PE文件数据区的初始化函数。<br><code>_initerm( __xc_a, __xc_z)</code>执行C++的初四化函数，全局对象的构造函数。<br>这块和编译器相关，不是特别确定，但是从各个资料，以及调试结果看是对的。具体编译器的处理逻辑是怎样的，这个就有点深入了，能力不及。待提高^_^……</p>
<p>其实<code>__xi_a</code>和<code>__xi_z</code>是两个全局变量，如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_CRTALLOC(&quot;.CRT$XIA&quot;) _PIFV __xi_a[];</span><br><span class="line">_CRTALLOC(&quot;.CRT$XIZ&quot;) _PIFV __xi_z[];    /* C initializers */</span><br><span class="line">_CRTALLOC(&quot;.CRT$XCA&quot;) _PVFV __xc_a[];</span><br><span class="line">_CRTALLOC(&quot;.CRT$XCZ&quot;) _PVFV __xc_z[];    /* C++ initializers */</span><br></pre></td></tr></table></figure></p>
<p>作为一个区域的开始于结束。编译器会将需要初始化的变量的函数放入两个变量之间。在<code>_initterm_e()</code>方法中会遍历这个区间内的所有指针，只要指针不为空，则将它当作函数调用。即完成对应的变量的初始化。对于C++的初始化代码类似，比如全局对象，会将对象的初始化函数放入到<code>__xc_a</code>和<code>__xc_z</code>之间，在程序CRT初始化时，就会调用到全局对象的初始化函数。同时在初始化函数中，会将对象的析构函数通过 atexit调用，注册到程序退出的回调函数列表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl _initterm_e (_PIFV * pfbegin, _PIFV * pfend)</span><br><span class="line">&#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        /*</span><br><span class="line">         * walk the table of function pointers from the bottom up, until</span><br><span class="line">         * the end is encountered.  Do not skip the first entry.  The initial</span><br><span class="line">         * value of pfbegin points to the first valid entry.  Do not try to</span><br><span class="line">         * execute what pfend points to.  Only entries before pfend are valid.</span><br><span class="line">         */</span><br><span class="line">        while ( pfbegin &lt; pfend  &amp;&amp; ret == 0) // &gt;</span><br><span class="line">        &#123;</span><br><span class="line">            /*</span><br><span class="line">             * if current table entry is non-NULL, call thru it.</span><br><span class="line">             */</span><br><span class="line">            if ( *pfbegin != NULL )</span><br><span class="line">                ret = (**pfbegin)();</span><br><span class="line">            ++pfbegin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有任何的动态初始化的<code>__declspec(thread)</code>的变量，则调用初始化函数。通过定义在tlsdyn.obj中的一个回调函数<code>__dyn_tls_init()</code>，来初始化这些变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (__dyn_tls_init_callback != NULL &amp;&amp;</span><br><span class="line">    _IsNonwritableInCurrentImage((PBYTE)&amp;__dyn_tls_init_callback))</span><br><span class="line">&#123;</span><br><span class="line">	__dyn_tls_init_callback(NULL, DLL_THREAD_ATTACH, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>9. 调用WinMain/main等函数</strong></p>
<p>对于Win32程序，处理命令行，过滤出命令行内容，传递给WinMain</p>
<p>对于控制台程序，直接调用main</p>
<p>最后对于托管程序，需要将main返回值 调用exit，而非托管程序，直接退出程序。</p>
<blockquote>
<p>在<code>_tWinMain()/_tmain()</code>函数调用时，会加一个<code>__try/__except</code> 的代码防护<br>&emsp;&emsp;这块内容在异常过滤的地方补充一下。</p>
</blockquote>
<h4 id="Win32程序与Console程序的一个不同点"><a href="#Win32程序与Console程序的一个不同点" class="headerlink" title="Win32程序与Console程序的一个不同点"></a>Win32程序与Console程序的一个不同点</h4><p>对于Win32应用程序，需要获取启动信息，在 gs的cookie值初始化完了，要获取一下Win32程序的启动信息。GetStartupInfo() 获取启动信息，包括界面实现的位置，窗口显示状态等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _STARTUPINFOA &#123;</span><br><span class="line">    DWORD   cb;</span><br><span class="line">    LPSTR   lpReserved;</span><br><span class="line">    LPSTR   lpDesktop;</span><br><span class="line">    LPSTR   lpTitle;</span><br><span class="line">    DWORD   dwX;</span><br><span class="line">    DWORD   dwY;</span><br><span class="line">    DWORD   dwXSize;</span><br><span class="line">    DWORD   dwYSize;</span><br><span class="line">    DWORD   dwXCountChars;</span><br><span class="line">    DWORD   dwYCountChars;</span><br><span class="line">    DWORD   dwFillAttribute;</span><br><span class="line">    DWORD   dwFlags;</span><br><span class="line">    WORD    wShowWindow;</span><br><span class="line">    WORD    cbReserved2;</span><br><span class="line">    LPBYTE  lpReserved2;</span><br><span class="line">    HANDLE  hStdInput;</span><br><span class="line">    HANDLE  hStdOutput;</span><br><span class="line">    HANDLE  hStdError;</span><br><span class="line">&#125; STARTUPINFOA, *LPSTARTUPINFOA;</span><br></pre></td></tr></table></figure>
<p><strong> 参考文章 </strong></p>
<ol>
<li>《软件调试》</li>
<li>VS2008运行时库源码</li>
</ol>
<p><strong> 修订历史 </strong></p>
<ul>
<li>2017-05-17 18:33:32    完成博文</li>
</ul>
<p>By Andy @2017-05-17 18:33:32</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/调试/">调试</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C-C/">C\C++</a><a href="/tags/运行时库/">运行时库</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://dbgtech.github.io/2017/05/17/C-runtime-library-analysis.html" data-title="C\C++运行时库源代码阅读 | DbgTech" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/05/21/Windows-Exception-Dispatch.html" title="Windows异常分发">
  <strong>上一篇：</strong><br/>
  <span>
  Windows异常分发</span>
</a>
</div>


<div class="next">
<a href="/2017/04/12/Windbg-error-outputerror.html"  title="Windbg的!error命令输出 Unable to get error code text">
 <strong>下一篇：</strong><br/> 
 <span>Windbg的!error命令输出 Unable to get error code text
</span>
</a>
</div>

</nav>

	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#动态链接会使用-crtexe-c中的内容"><span class="toc-number">1.</span> <span class="toc-text">动态链接会使用 crtexe.c中的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态链接会使用-crt0-c中的内容"><span class="toc-number">2.</span> <span class="toc-text">静态链接会使用 crt0.c中的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Win32程序与Console程序的一个不同点"><span class="toc-number">3.</span> <span class="toc-text">Win32程序与Console程序的一个不同点</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  <div class="linkslist">
  <p class="asidetitle">专栏</p>
    <ul>
        
          <li>
            
            	<a href="https://dbgtech.github.io/Tools/" target="_blank" title="常用工具">常用工具</a>
            
          </li>
        
    </ul>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/散记/" title="散记">散记<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/笔记/" title="笔记">笔记<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/翻译/笔记/" title="笔记">笔记<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/翻译/" title="翻译">翻译<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/读书/" title="读书">读书<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/调试/" title="调试">调试<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/转载/" title="转载">转载<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Windbg/" title="Windbg">Windbg<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Exception/" title="Exception">Exception<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Windows/" title="Windows">Windows<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/心情/" title="心情">心情<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/X86汇编/" title="X86汇编">X86汇编<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Markdown/" title="Markdown">Markdown<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/笔记/" title="笔记">笔记<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Stack-Cookie/" title="Stack Cookie">Stack Cookie<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/time/" title="time">time<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C-C/" title="C/C++">C/C++<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Win10/" title="Win10">Win10<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/UWP/" title="UWP">UWP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/读书笔记/" title="读书笔记">读书笔记<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C-C/" title="C\C++">C\C++<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/反思/" title="反思">反思<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/翻译/" title="翻译">翻译<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/实模式/" title="实模式">实模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/保护模式/" title="保护模式">保护模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/运行时库/" title="运行时库">运行时库<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/WSL/" title="WSL">WSL<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://git-scm.com/book/zh/v2" target="_blank" title="Git">Git</a>
            
          </li>
        
          <li>
            
            	<a href="https://hexo.io/zh-cn/docs/" target="_blank" title="Hexo">Hexo</a>
            
          </li>
        
          <li>
            
            	<a href="http://36kr.com/" target="_blank" title="36氪">36氪</a>
            
          </li>
        
          <li>
            
            	<a href="https://wiki.osdev.org/Expanded_Main_Page" target="_blank" title="OSDev">OSDev</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.reactos.com/" target="_blank" title="ReactOS">ReactOS</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.freebuf.com/" target="_blank" title="FreeBuf">FreeBuf</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.appinn.com/markdown/" target="_blank" title="Makedown">Makedown</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.huxiu.com/" target="_blank" title="虎嗅网">虎嗅网</a>
            
          </li>
        
          <li>
            
            	<a href="http://bbs.pediy.com/" target="_blank" title="看雪论坛">看雪论坛</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.geekpark.net/" target="_blank" title="极客公园">极客公园</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">归档</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li></ul>
  </div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="Andy Guo">Andy Guo</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>

